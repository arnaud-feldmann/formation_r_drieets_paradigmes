---
title: "Rappel sur les fonctions en R"
---

## Définition de fonction

En R, on définit une fonction de cette manière :

```{webr-r}
super_calcul <- function(a, b, multiplication = TRUE) {
  if (multiplication) a * b
  else a + b
}

# Calcul 1
print(super_calcul(2, 3, TRUE))

# Calcul 2
# Même valeur que le calcul 1 car multiplication vaut TRUE par défaut
print(super_calcul(2, 3))

# Calcul 3
print(super_calcul(2, 3, FALSE))

# Calcul 4
# Même valeur que le calcul 3, on a juste nommé explicitement
print(super_calcul(a = 2, b = 3, FALSE))

# Calcul 5
# Même valeur que le calcul 3, nommer explicitement permet d'intervertir les arguments
print(super_calcul(b = 3, a = 2, FALSE))

# Calcul 6
# Même valeur que le calcul 3, cas extrême d'interversion
print(super_calcul(b = 3, 2, FALSE))
```

La fonction `super_calcul` a plusieurs **paramètres** : `a`, `b` et `multiplication`. On donne à ces paramètres des valeurs qu'on appelle **arguments**. Toutefois, dans le langage courant, et peut-être dans cette formation si je ne fais pas trop attention, on utilise parfois indistinctement les deux mots.

On remarque que le paramètre multiplication a un argument par défaut. Si on omet de lui donner une valeur, sa valeur par défaut sera `TRUE`.

On remarque aussi que, lorsque l'on fait des appels de fonctions, l'on peut choisir d'utiliser explicitement les noms des différents paramètres. Si on utilise les noms explicites, il est possible de les renseigner dans le désordre.

```{webr-r}
super_calcul <- function(a, b, multiplication = TRUE) {
  if (multiplication) a * b
  else a + b
}
print(super_calcul(2))
```

Le code ci-dessus renvoie une erreur. En effet, si un paramètre n'a pas de valeur par défaut, une valeur doit obligatoirement être assignée lors de l'appel de fonction.

::: callout-note

La dernière remarque n'est pas complètement vraie. Du vieux code persiste dans R, renseignant des arguments par défaut dans le code même de la fonction, à l'aide de `if (missing(argument)) {}`. Ceci est toutefois, en général, [considéré comme une mauvaise pratique](https://design.tidyverse.org/def-magical.html).

:::

On vient de constater de manière implicite un aspect de R : par défaut, la valeur retournée par une fonction est la dernière valeur évaluée lors de son exécution (qui dépend éventuellement de structures telles que `if () else {}`). Une manière explicite de renvoyer une valeur de retour est d'invoquer `return()`. Appeler `return()` met fin à l'exécution de la fonction. Tout ce qui vient après n'est jamais rappelé.

```{webr-r}
calcula <- function() {
  1L
  return(2L)
  3L
}
print(calcula())

calculb <- function() {
  1L
  2L
  3L
}
print(calculb())
```

`calcula()` renvoie 2L, tandis que `calculb()` renvoie 3L. On aurait pu également constater que, dans `calcula`, si on remplace 3L par `stop()`, le stop n'empêche pas la fonction de retourner convenablement. En effet, il arrive après le return.

## Dots

Lorsque le nombre de paramètres d'une fonction peut être variable, on peut utiliser les `...` qu'on appelle "dots". `list(...)` permet de retrouver ces arguments sous forme de liste dans le corps de la fonction.

```{webr-r}
super_somme <- function(...) {
  dots <- list(...)
  Reduce(`+`, dots)
}
print(super_somme(2, 3, 7, 1))
```

Dans le code précédent, on a pu faire une fonction de somme sans figer à l'avance le nombre de termes de la somme.

::: callout-note

On a utilisé dans `super_somme` une fonction particulière, `Reduce`, qui est typique des langages fonctionnels. L'idée est ici que l'on calcule `2 + 3 + 7 + 1`. On verra plus en détail ce type d'opérations dans la partie dédiée au paradigme fonctionnel.

:::

## Appeler une fonction dots sur une liste

Imaginons que l'on veuille appeler une fonction `...` sur une liste. On souhaite que chaque élément de la liste devienne un argument. On peut par exemple faire, sur notre fonction `super_somme`.

```{webr-r}
liste <- list(2, 3, 7, 1)
super_somme <- function(...) {
  dots <- list(...)
  Reduce(`+`, dots)
}
print(do.call(super_somme, liste))
```

::: callout-note

La fonction `do.call` est en réalité plus générale que cela. Elle permet également d'utiliser des arguments nommés, comme on peut le voir dans l'exemple suivant :

```{webr-r}
do.call(paste, list("a", "b", "c", sep = "/"))
```

:::

## Fonction récursives

Les fonctions en R peuvent tout-à-fait être récursives. Par exemple, même si `factorial()` existe déjà dans R, on pourrait très bien la redéfinir via :

```{webr-r}
fact <- function(n) {
  if (n == 1L) 1L
  else n * fact(n - 1L)
}
fact(10)
```

R permet également une petite astuce pour éviter d'avoir à utiliser le nom d'une fonction dans son propre corps (cela permet de pouvoir renommer la fonction à un seul endroit). Le code précédent est équivalent à :

```{webr-r}
fact <- function(n) {
  if (n == 1L) 1L
  else n * Recall(n - 1L)
}
fact(10)
```

::: callout-note

## Remarque optionnelle

Depuis la dernière version de R (pas avant !), on peut utiliser la fonction `Tailcall` pour faire des **récursivités terminales** ; qui sont moins pratiques à lire mais plus efficaces. L'interface n'est pas encore figée mais cela ressemble aujourd'hui à cela.

```{webr-r}
fact <- function(n, acc = 1) {
  if (n == 1L) acc
  else {
    acc <- acc * n
    Tailcall(fact, n - 1L, acc)
  }
}
fact(10)
```

:::

## Quizz

**Question 1**

::: question

Réécrire la fonction `super_somme` en utilisant une syntaxe récursive. On pourra, par exemple, s'aider de la fonction `head`, qui permet de retourner une sous-liste contenant les n premiers éléments d'une liste.

:::

```{webr-r}
```

::: {.callout-tip collapse="true"}
## Proposition de solution

```{r}
super_somme <- function(...) {
  dots <- list(...)
  longueur <- length(dots)
  if (longueur == 0L) 0
  else dots[[longueur]] + do.call(super_somme, head(dots, longueur - 1L))
}
print(super_somme(2, 3, 7, 1))
```

::: callout-note

## Remarque

- La récursivité est ici très bourrine ! On le fait juste pour l'exercice.
- Quelques petites astuces permettent, si besoin, d'éviter de convertir tous les arguments d'une fonction dots en liste. On dispose par exemple de `...length()` en tant que substitut pour `length(list(...))`.

:::

:::

**Question 2**

Ecrire une fonction `...` `super_produit` qui calcule le produit de tous les arguments, et l'utiliser pour écrire une nouvelle version de la fonction `fact`.

```{webr-r}
```

::: {.callout-tip collapse="true"}
## Proposition de solution

```{r}
super_produit <- function(...) {
  dots <- list(...)
  Reduce(`*`, dots)
}
fact <- function(n) {
  do.call(super_produit, as.list(1L:n))
}
fact(10)
```

:::

**Question 3**

Ecrire une fonction dots `usine_a_gaz` qui renvoie :

* `NULL` s'il n'y a aucun argument.
* Le nombre d'arguments s'il y en a deux ou plus.
* `"bonjour"` si on lui soumet en unique argument un vecteur de type character.
* La somme du vecteur si on lui soumet en unique argument un vecteur numérique au sens de `is.numeric`.
* `"échec"` dans tous les autres cas.

On pourra *éventuellement* s'aider des petites astuces, dont `...length()`, lisibles dans la page d'aide des `...`. Celle-ci est accessible en tapant `?dots`.

```{webr-r}
```

::: {.callout-tip collapse="true"}

## Proposition de solution

```{r}
usine_a_gaz <- function(...) {
  longueur <- ...length()
  if (longueur == 0) NULL
  else if (longueur >= 2L) longueur
  else if (is.character(..1)) "bonjour"
  else if (is.numeric(..1)) sum(..1)
  else "échec"
}
print(usine_a_gaz())
print(usine_a_gaz(1,3))
print(usine_a_gaz(c("a","b")))
print(usine_a_gaz(c(1, 2)))
print(usine_a_gaz(c(1L, 2L)))
print(usine_a_gaz(list()))
```

On peut également utiliser des `return()`, auquel cas les `else` deviennent inutiles puisque `return` fait directement retourner la fonction.

```{r}
usine_a_gaz <- function(...) {
  longueur <- ...length()
  if (longueur == 0) return(NULL)
  if (longueur >= 2L) return(longueur)
  if (is.character(..1)) return("bonjour")
  if (is.numeric(..1)) return(sum(..1))
  "échec"
}
print(usine_a_gaz())
print(usine_a_gaz(1,3))
print(usine_a_gaz(c("a","b")))
print(usine_a_gaz(c(1, 2)))
print(usine_a_gaz(c(1L, 2L)))
print(usine_a_gaz(list()))
```

:::