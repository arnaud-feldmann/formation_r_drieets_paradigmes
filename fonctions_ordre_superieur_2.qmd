---
title: "Fonctions d'ordre supérieur (retours)"
---

## Les environnements

Que se passe-t-il par exemple quand j'exécute ce code R ? On y appelle une fonction qui renvoie elle-même une fonction. Il y a plein de choses qui s'appellent `x` ! Comment cela peut bien se résoudre ?

::: callout-note

On l'a vu dans la partie précédente, ces fonctions retournant des fonctions sont un des deux types de fonction d'ordre supérieur.

:::

```{webr-r}
x <- 1L
mystere <-
  function(arg) {
    x <- 2L
    function() {
      x <- arg
      return(x)
    }
  }

fun_1 <- mystere(3L)
fun_2 <- mystere(4L)
print(x)
print(fun_1())
print(x)
print(fun_2())
print(x)
```

On se rend compte de quatre choses :

* Aucune des assignations (`<-`) internes aux fonctions n'a modifié l'environnement global ; `print(x)` affiche toujours `1L`.
* Le `arg` de la fonction mystère semble avoir été passé 
* Le résultat du x retourné par `fun_1()` est celui défini à l'intérieur de la fonction anonyme, à savoir `3L`.
* Le résultat du x retourné par `fun_2()` est celui défini à l'intérieur de la fonction anonyme, à savoir `4L`.

Pourquoi donc ?

![](environnements.svg)

Dans R, les objets sont contenus dans des *environnements*. Les environnements sont plus ou moins des petites bulles :

* dans lesquelles on peut assigner des objets (avec`<-`) de manière totalement isolée les unes des autres. Ici il faut bien comprendre que tous les objets `x` existent en même temps dans des environnements différents.
* à l'exception de l'emptyenv, tous les environnements indiquent un environnement parent.
* Chaque **appel** de fonction (et non chaque définition) définit un environnement. Ici on crée donc deux environnements différents pour mystere qu'on appelle des *instances*.
* lorsque l'on recherche un objet dans un environnement et qu'il n'y existe pas, on va chercher dans l'environnement parent (puis à nouveau l'environnement parent si on ne trouve toujours pas et ainsi de suite). Ici, par exemple, `fun_1` n'a pas connaissance de `arg`. Alors on cherche dans l'environnement au dessus. Surprise ! On y trouve arg et l'on peut donc assigner avec cette valeur. C'est ce qui explique que `fun_1()` et `fun_2()` peuvent renvoyer des résultats différents.

Dans la suite, on s'attardera surtout sur la partie bleue du graphique ci-dessus. La partie orange a été abordée à titre d'information, mais n'est pas vraiment le sujet ici. De notre point de vue, l'environnement le plus bas est donc le globalenv.

## L'assignation remontante (`<<-`)

On remplace les deux assignations intra-fonctionnelles par un nouvel opérateur, l'assignation remontante `<<-`.

```{webr-r}
x <- 1L
mystere <-
  function(arg) {
    x <<- 2L
    function() {
      x <<- arg
      return(x)
    }
  }

fun_1 <- mystere(3L)
fun_2 <- mystere(4L)
print(x)
print(fun_1())
print(x)
print(fun_2())
print(x)
```

On observe que le `x` global est cette fois-ci modifié par l'assignation remontante. En effet, cet opérateur **remonte les différents environnements jusqu'à trouver un x déjà existant et le modifie**.

Ici, à chaque affectation, on remonte donc jusqu'à l'environnement global et on trouve `x`. On modifie alors celui-ci.

![](environnements2.svg)

À la fin de l'exécution, on a donc le schéma ci-dessus. On n'a pas créé de version locale de `x`.

::: callout-warning

## Ne pas assigner le global

Attention cependant, quand bien même l'opérateur `<<-` peut théoriquement créer des fonctions manipulant l'environnement global comme on vient de le voir, ce n'est pas une bonne pratique. L'utilisation de `<<-` doit être fait de manière circonscrite à des cas que l'on va aborder dans la suite de cette page, mais modifier l'environnement global est une (très) mauvaise pratique. En effet, cela rompt complètement le paradigme fonctionnel dès lors que l'on a des états globaux pouvant mener à des interdépendances, des problèmes d'isolation...

:::

Que se passe-t-il si on n'utilise l'assignation remontante **que** dans la fonction anonyme et plus pour le `x <- 2L` de la fonction de second ordre ? Pourquoi ?

```{webr-r}
# Vous pouvez essayer ici.
```

::: {.callout-tip collapse="true"}

## Réponse

```{r}
x <- 1L
mystere <-
  function(arg) {
    x <- 2L
    function() {
      x <<- arg
      return(x)
    }
  }

fun_1 <- mystere(3L)
fun_2 <- mystere(4L)
print(x)
print(fun_1())
print(x)
print(fun_2())
print(x)
```

En apparence, les fonctions semblent se comporter à nouveau comme si on utilisait l'assignation locale. Mais, en réalité, le comportement par environnements est différent.

![](environnements3.svg)

À la fin de l'exécution on a le graphe ci-dessus. Les `x <- 2L` des différentes instances de mystère ont été ecrasés respectivement par les `x <<- 3L` et `x <<- 4L` de `fun_1` `fun_2`. Ici, comme on n'utilise de toutes manières pas les valeur `2L`, ce n'est pas très grave. On préserve l'isolation entre instances donc tout va bien ; même si ici la notation est inutile.

:::

## Closures

On a vu plus que des fonctions peuvent retourner des fonctions, et qu'il s'agit d'un des deux types de fonctions d'ordre supérieur. Dans R, on appelle aussi ces fonctions des *closures* (fermetures en français, mais le terme n'est pas très employé).

Ce nom illustre un aspect de ces fonctions d'ordre supérieur, et une utilisation particulière. On a vu qu'il est possible d'écrire dans l'environnement *parent* tout en préservant l'isolation entre instances. Et bien utilisons cette propriété !

```{webr-r}
nouveau_compteur <-
  function() {
    n <- 0L
    function() {
      n <<- n + 1L
      return(n)
    }
  }

compteur_1 <- nouveau_compteur()
compteur_2 <- nouveau_compteur()
print(compteur_1())
print(compteur_1())
print(compteur_2())
print(compteur_1())
print(compteur_1())
print(compteur_2())
```

Mais que se passe-t-il ? C'est très étonnant ! Il semble que l'on ait défini des états ; et pourtant il n'y a aucune variable `n` dans l'environnement global !

![](environnements4.svg)

En fait, on appelle ces fonctions des closures parce qu'elles "enferment" leur environnement parent. Elle permettent de maintenir un espace isolé où l'on peut tout-à-fait faire des modifications.

Cette astuce est puissante et permet de maintenir des états à l'intérieur d'un langage fonctionnel. Cela rompt l'axiome maximaliste d'un langage fonctionnel idéal qui ne contiendrait que des fonctions complètement pures, mais cela rompt cette approche de manière maitrisée, la plus locale possible. On doit bien sûr n'user de cette astuce qu'avec parcimonie, quand cela semble nécessaire.

## Closures complexes

Une closure peut renvoyer plusieurs fonctions différentes par exemple dans une liste. On s'approche alors beaucoup de la définition d'un objet en Programmation Orientée Objet. En effet, chaque instance de fonctions a des états, et différentes méthodes qui permettent de modifier ces états.

```{webr-r}
nouvelle_resolution <-
  function() {
    x <- 0L
    y <- 0L
    list(
      setX = function(val) x <<- val,
      setY = function(val) y <<- val,
      getX = function() x,
      getY = function() y
    )
  }

resolution_1 <- nouvelle_resolution()
resolution_2 <- nouvelle_resolution()
resolution_1$setX(1080)
resolution_1$setY(1024)
resolution_2$setX(800)
resolution_2$setY(600)
print(resolution_1$getX())
print(resolution_1$getY())
print(resolution_2$getX())
print(resolution_2$getY())
```

Ici, les deux appels de `nouvelle_resolution()` permettent de définir deux espaces différents. Dans chacun de ces environnements, les fonctions `setX()`, `setY()`, `getX()` et `getY()` agiront, comme on le voit dans le schéma ci-dessous.

![](environnements5.svg)