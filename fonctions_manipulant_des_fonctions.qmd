---
title: "Fonctions manipulant des fonctions"
---

## Manipuler des fonctions avec des fonctions

On a vu dans le point précédent deux fonctions qui s'appliquent sur des fonctions. `do.call` nous a permis d'appliquer une fonction `...` sur une liste, tandis que Reduce nous a permis d'écrire `2 + 3 + 7 + 1` de manière un peu plus jolie qu'à la main.

On a vu aussi que R est un langage principalement fonctionnel. En fait, R offre un certain nombre de fonctions permettant d'appliquer des fonctions de différentes manières. Nous verrons ici `lapply`, `vapply`, `Map`, `replicate`, `apply`, `do.call`, `Reduce`.

![Schéma des différentes fonctions de manipulation](dessin_fonctions_manipulation.svg)

## lapply : appliquer une fonction à chaque élément d'une liste ou d'un vecteur

```{webr-r}
begaiement <-
  lapply(
    list(c("a", "b"),
         c("c", "d", "e"),
         c("f", "g")),
    function(x) c(x, x, x)
  )
print(begaiement)
print(typeof(begaiement))
print(class(begaiement))
```

La fonction `function(x) c(x, x, x)` demande à répéter trois fois un élément. Cette fonction est appliquée terme à terme à chaque élement de la liste.

* `c("a", "b")` donne `c("a", "b", "a", "b", "a", "b")`
* `c("c", "d", "e")` donne `c("c", "d", "e", "c", "d", "e", "c", "d", "e")`
* `c("f", "g")` donne `c("f", "g", "f", "g", "f", "g")`

```{webr-r}
tripler_les_elements <- function(liste) {
  lapply(liste, function(x) c(x, x, x))
}
begaiement <-
  tripler_les_elements(
    list(c("a", "b"),
         c("c", "d", "e"),
         c("f", "g")))
print(begaiement)
print(typeof(begaiement))
print(class(begaiement))
```

Le calcul ci-dessus montre qu'on peut utiliser `lapply` à l'intérieur d'une autre fonction.

```{webr-r}
tripler <- function(x) c(x, x, x)

tripler_les_elements <- function(liste) {
  lapply(liste, tripler)
}
begaiement <-
  tripler_les_elements(
    list(c("a", "b"),
         c("c", "d", "e"),
         c("f", "g")))
print(begaiement)
print(typeof(begaiement))
print(class(begaiement))
```

Ce calcul illustre un aspect implicite des deux précédentes syntaxes utilisées : celles-ci utilisent `function(x) c(x, x, x)` en lieu et place d'un nom de fonction à l'intérieur du lapply ! On appelle cela des *fonctions anonymes*. Si une fonction n'a pour vocation que d'être utilisée une seule fois, cela peut rendre la syntaxe plus claire et plus élégante qu'une *fonction nommée*.

```{webr-r}
begaiement_bis <-
  tripler_les_elements(c("a", "b", "c", "d"))
print(begaiement_bis)
print(typeof(begaiement_bis))
print(class(begaiement_bis))
```

Dans ce dernier calcul, on remarque que l'on peut appliquer `lapply` sur un vecteur.

Dans les 4 calculs, on se rend compte que le résultat de lapply est une liste. lapply retourne en effet une liste même dans le cas du quatrième calcul qui lui soumet un vecteur.

::: callout-note

Dans les versions de R récentes, on peut utiliser la notation compacte `\(x) c(x, x, x)` à la place de `function(x) c(x, x, x)` pour désigner une fonction.

À l'intérieur de l'écosystème tidyverse, on peut également utiliser la notation très compacte `~c(.x, .x, .x)`.

:::

# vapply : une sorte de lapply mais avec une sortie sous forme d'un vecteur ou d'une matrice.

On l'a vu dans les exemples précédents, `lapply` renvoie tous les élements sous la forme d'une liste. Mais une liste n'est pas un objet très pratique à manipuler dans un un langage vectoriel ! la fonction `vapply` permet de retourner les résultats sous la forme d'un vecteur ou d'une matrice. La syntaxe est un peu particulière mais on s'y habitue vite !

```{webr-r}
vecteur <- vapply(list(3L, 7L, -1L), \(x) x + 1L, 0L)
print(vecteur)
print(typeof(vecteur))
print(class(vecteur))
```

`vapply` applique la fonction anonyme `\(x) x + 1L` sur chaque élément de la liste `list(3L, 7L, -1L)` et renvoie un vecteur de type similaire à `0L` (c'est-à-dire un `"integer"`)

```{webr-r}
vecteur <- vapply(list(3L, 7L, -1L), \(x) x + 1L, 133123128L)
print(vecteur)
print(typeof(vecteur))
print(class(vecteur))
```

Ce calcul est exactement similaire au précédent. Ce qui est mis en avant ici, c'est que seul le type du troisième argument (`FUN.VALUE`) importe, sa valeur n'a aucune importance. Ici, si on veut retourner un vecteur entier, n'importe quel entier de taille 1 fait l'affaire.

```{webr-r}
matrice <-
  vapply(
    c("a", "b", "c", "d"),
    \(x) c(x, x, x),
    c("", "", "")
  )
print(matrice)
print(typeof(matrice))
print(class(matrice))
```

Dans le cas où, comme ici, chaque *application unitaire* de la fonction utilisée retourne plusieurs valeurs, alors l'argument `FUN.VALUE` doit être un vecteur de même taille.

* L'application de `\(x) c(x, x, x)` sur `"a"` donne `c("a", "a", "a")`.
* L'application de `\(x) c(x, x, x)` sur `"b"` donne `c("b", "b", "b")`.
* L'application de `\(x) c(x, x, x)` sur `"c"` donne `c("c", "c", "c")`.
* L'application de `\(x) c(x, x, x)` sur `"d"` donne `c("d", "d", "d")`.

On attend bien trois objets de taille 3.

Par conséquent, l'objet en retour sera une *matrice* et non plus un vecteur. Comme dans le cas vectoriel, son type est déterminé par celui de `FUN.VALUE`.

```{webr-r}
matrice <-
  vapply(
    c("a", "b", "c", "d"),
    \(x) c(x, x, x),
    c("je", "suis", "arbitraire")
  )
print(matrice)
print(typeof(matrice))
print(class(matrice))
```

Là encore, on remarque que les valeurs de l'argument `FUN.VALUE` sont purement arbitraires. Seules sa longueur et son type importent.

```{webr-r}
vecteur <- sapply(list(3L, 7L, -1L), \(x) x + 1L)
print(vecteur)
print(typeof(vecteur))
print(class(vecteur))
```

Lorsque l'on veut faire vite dans la console et que l'on n'a pas le temps de réfléchir, un raccourci pour `vapply` existe sans la `FUN.VALUE`. La fonction `sapply` devine automatiquement les dimensions et le type requis. Utiliser un `vapply` explicite est cependant une meilleure pratique à l'intérieur d'un programme.

```{webr-r}
matrice <-
  sapply(
    c("a", "b", "c", "d"),
    \(x) c(x, x, x)
  )
print(matrice)
print(typeof(matrice))
print(class(matrice))
```

::: callout-warning

## sapply est plus laxiste que vapply

Essayer d'utiliser un `sapply` sur :

```{r}
#| eval: false
lapply(
  list(c("a", "b"),
       c("c", "d", "e"),
       c("f", "g")),
  function(x) c(x, x, x)
)
```

```{webr-r}
# Vous pouvez essayer ici.
```

Que se passe-t-il ? Pourquoi ? Peut-on résoudre ce problème avec un vapply ?

::: {.callout-tip collapse="true"}

## Réponse

La liste en entrée du `sapply` est une liste de vecteurs de tailles variables. On répète trois fois ses éléments. Les vecteurs en **sortie** seront donc de tailles variables également ; et c'est ce qui est rédhibitoire pour que le sapply puisse déterminer une dimension de matrice adéquate. Il laisse donc le résultat sous la forme d'une liste.

On ne peut pas résoudre ce problème structurel avec un `vapply`, mais vapply a le mérite d'être plus strict : il renverra une erreur si les valeurs ne sont pas de la dimension explicitement demandée.

:::

:::

## Map : appliquer une fonction multi-paramètres termes à termes

On a vu avec `lapply` comment appliquer une fonction sur chaque termes d'*une* liste ou d'un vecteur et retourner une liste. Cependant, parfois, un seul argument ne suffit pas, et l'on a envie d'appliquer une fonction terme à terme sur plusieurs listes ou vecteurs. La fonction `Map` remplit ce besoin.

```{webr-r}
Map(paste,
    c("a", "b", "c"),
    c("d", "e", "f"))
```

On voit ici que la fonction Map permet d'appliquer termet à terme la fonction paste sur deux vecteurs.

```{webr-r}
Map(paste,
    c("a", "b", "c"),
    c("d", "e", "f"),
    MoreArgs = list(sep = ""))
```

L'argument `MoreArgs` de `Map` permet de rajouter une liste d'arguments complémentaires, qui restent fixes entre tous les appels.

```{webr-r}
Map(\(x) paste(x, sep = ""),
    c("a", "b", "c"),
    c("d", "e", "f"))
```

On aurait aussi tout aussi pu utiliser une fonction anonyme pour spécifier des arguments complémentaires. C'est au choix !

```{webr-r}
Map(paste,
    c("a", "b", "c"),
    c("d", "e", "f"),
    c("g", "h", "i"))
```

La fonction `Map` peut utiliser autant d'arguments que l'on veut, dès lors que la fonction mappée est compatible avec ce nombre d'arguments.

```{webr-r}
Map(`+`,
    list(c(1L, 2L, 3L), c(4L, 5L, 6L, 7L), c(8L, 9L)),
    list(c(10L, 11L, 12L), c(13L, 14L, 15L, 16L), c(17L, 18L)))
```

La fonction `Map` peut tout-à-fait utiliser des listes. Ici, elle renvoie donc une liste appliquant la fonction `+` terme à terme :

* `c(1L, 2L, 3L) + c(10L, 11L, 12L)` pour le premier terme.
* `c(4L, 5L, 6L, 7L) + c(13L, 14L, 15L, 16L)` pour le deuxième terme.
* `c(8L, 9L) + c(17L, 18L)` pour le troisième terme.

## replicate : une variante commode de lapply pour les générations de nombres aléatoires

Certaines fonctions utiles en statistiques génèrent des nombres aléatoires. Par exemple, `runif(2L)` renvoie 2L nombres entre 0 et 1 selon une loi uniforme. Si on veut générer 4 vecteurs de 2 nombres aléatoires, on voudrait faire un lapply sur `function() runif(2L)`.

Le problème, c'est que cette fonction est sans paramètre. Du coup comment lui spécifier un `lapply` ?

```{webr-r}
lapply(rep(2L, 4L),
       function(n) runif(n))
```

L'astuce ci-dessus permet de résoudre le problème ; on a répété 4 fois le 2L. On applique ensuite donc `function(n) runif(n)` sur `c(2L, 2L, 2L, 2L)`. Chaque élément du vecteur renvoie alors un vecteur de deux nombres aléatoires. Ce n'est cependant pas des plus élégants.

```{webr-r}
replicate(4L, runif(2L), simplify = FALSE)
```

`replicate` est une variante de lapply qui permet d'évaluer une *expression* plusieurs fois de suite. Cela n'est, bien entendu, utile que dans le cas où cette expression renvoie des résultats différents à chaque évaluation, ce qui est notamment le cas en ce qui concerne la générations de nombres aléatoires.

On note l'argument `simplify = FALSE` à la fin. Si celui-ci n'est pas spécifié, il est par défaut défini à la valeur `TRUE`, et alors replicate se comporte comme un `sapply` ; il essaye de construire des matrices.

## apply : appliquer une fonction sur les colonnes ou les lignes d'une matrice

`apply` permet d'appliquer une fonction par ligne ou par colonne.

```{webr-r}
matrice <-
  matrix(1:12,
         nrow = 3L)
print(matrice)
apply(matrice,
      1L,
      max)
apply(matrice,
      2L,
      max)
```

Dans le tronçon de code ci-dessus, on a appliqué la fonction `max` (maximum) respectivement sur chaque ligne et chaque colonne. C'est l'argument `MARGIN` en deuxième position qui permet de déterminer la direction de cette application de fonction (`1` pour les lignes, `2` pour les colonnes).

::: callout-note

Il est à noter que quelques optimisations de ces fonctions existent. `rowSums`, `colSums`, `rowMeans`, `colMeans` ont toutes les quatre des noms assez parlants qui permettent d'éviter une écriture un peu trop poussive.

:::

## do.call : appliquer une fonction multi-paramètres sur une liste d'arguments

La fonction `do.call` permet d'utiliser une fonction multi-paramètres, par exemple (mais pas obligatoirement) une fonction dépendant de paramètres en dots `...`, sur une liste de valeurs.

```{webr-r}
do.call(paste, list("a", "b", "c", sep = "/"))
```

Ici, on a appliqué la fonction `paste` en même temps sur chaque élément de la liste fournie en argument. On peut noter, également, que les éléments nommés de la liste (ici `sep`) sont traduits par des arguments nommés.

## Reduce : réduire une liste ou un vecteur d'arguments par application successive d'un opérateur binaire

La fonction `Reduce` permet d'appliquer consécutivement une opération binaire.

```{webr-r}
Reduce(`+`, c(1, 2, 8, -7))
```

Cet exemple (que l'on a déjà vu dans le chapitre précédent) correspond à `((1 + 2) + 8) + (-7)`. Chaque étape utilise l'opération binaire `+`. Mais `Reduce` peut être employé dans des calculs plus complexes.

```{web-r}
liste_fonctions <- list(
  \(x) x + 1,
  \(x) x / 3,
  atan
)

composer_fonctions <- function(e1, e2) {
  e1 <- match.fun(e1)
  e2 <- match.fun(e2)
  function(...) {
    e1(e2(...))
  }
}

fonction_composee <- Reduce(composer_fonctions, liste_fonctions)

print(fonction_composee(pi))
print(atan(pi) / 3 + 1)
```

Dans l'exemple précédent, on a appliqué sur une liste de fonctions l'opérateur `Reduce` au sens de la composition. C'est un joli exemple pour montrer la richesse d'un langage fonctionnel et illustrer l'idée que `Reduce` n'est pas restreint à des opérations numériques. En général, cependant, on préfèrera éviter d'empiler des fonctions non-évaluées. On préfèrera donc une notation intermédiaire comme employé ci-dessous.

```{web-r}
liste_fonctions <- list(
  \(x) x + 1,
  \(x) x / 3,
  atan
)

appliquer_fonction <- function(f, accumulateur) {
  f <- match.fun(f)
  f(accumulateur)
}

Reduce(appliquer_fonction, liste_fonctions, init = pi, right = TRUE)
```

Ici, plutôt que d'empiler des fonctions en mémoire, on les applique successivement. `applique_fonction` reste une opération binaire, mais est une loi de composition externe, dans la mesure où `f` est une fonction tandis que `accumulateur` est un résultat numérique. On remarque aussi qu'on a utilisé l'argument `init` de `Reduce` qui permet d'initialiser l'accumulateur. En effet si on veut obtenir `atan(pi) / 3 + 1` il faut bien renseigner qu'on commence à `pi` quelque part. L'argument `right = TRUE` permet de parcourir la liste de droite à gauche plutôt que de gauche à droite.
