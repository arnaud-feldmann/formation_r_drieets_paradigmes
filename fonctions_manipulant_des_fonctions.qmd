---
title: "Fonctions manipulant des fonctions"
---

## Manipuler des fonctions avec des fonctions

On a vu dans le point précédent deux fonctions qui s'appliquent sur des fonctions. `do.call` nous a permis d'appliquer une fonction `...` sur une liste, tandis que Reduce nous a permis d'écrire `2 + 3 + 7 + 1` de manière un peu plus jolie qu'à la main.

On a vu aussi que R est un langage principalement fonctionnel. En fait, R offre un certain nombre de fonctions permettant d'appliquer des fonctions de différentes manières. Nous verrons ici `lapply`, `vapply`, `Map`, `replicate`, `apply`, `do.call`, `Reduce`.

## lapply : appliquer une fonction à chaque élément d'une liste ou d'un vecteur

```{webr-r}
begaiement <-
  lapply(
    list(c("a", "b"),
         c("c", "d", "e"),
         c("f", "g")),
    function(x) c(x, x, x)
  )
print(begaiement)
print(typeof(begaiement))
print(class(begaiement))
```

La fonction `function(x) c(x, x, x)` demande à répéter trois fois un élément. Cette fonction est appliquée terme à terme à chaque élement de la liste.

* `c("a", "b")` donne `c("a", "b", "a", "b", "a", "b")`
* `c("c", "d", "e")` donne `c("c", "d", "e", "c", "d", "e", "c", "d", "e")`
* `c("f", "g")` donne `c("f", "g", "f", "g", "f", "g")`

```{webr-r}
tripler_les_elements <- function(liste) {
  lapply(liste, function(x) c(x, x, x))
}
begaiement <-
  tripler_les_elements(
    list(c("a", "b"),
         c("c", "d", "e"),
         c("f", "g")))
print(begaiement)
print(typeof(begaiement))
print(class(begaiement))
```

Le calcul ci-dessus montre qu'on peut utiliser `lapply` à l'intérieur d'une autre fonction.

```{webr-r}
tripler <- function(x) c(x, x, x)

tripler_les_elements <- function(liste) {
  lapply(liste, tripler)
}
begaiement <-
  tripler_les_elements(
    list(c("a", "b"),
         c("c", "d", "e"),
         c("f", "g")))
print(begaiement)
print(typeof(begaiement))
print(class(begaiement))
```

Ce calcul illustre un aspect implicite des deux précédentes syntaxes utilisées : celles-ci utilisent `function(x) c(x, x, x)` en lieu et place d'un nom de fonction à l'intérieur du lapply ! On appelle cela des *fonctions anonymes*. Si une fonction n'a pour vocation que d'être utilisée une seule fois, cela peut rendre la syntaxe plus claire et plus élégante qu'une *fonction nommée*.

```{webr-r}
begaiement_bis <-
  tripler_les_elements(c("a", "b", "c", "d"))
print(begaiement_bis)
print(typeof(begaiement_bis))
print(class(begaiement_bis))
```

Dans ce dernier calcul, on remarque que l'on peut appliquer `lapply` sur un vecteur.

Dans les 4 calculs, on se rend compte que le résultat de lapply est une liste. lapply retourne en effet une liste même dans le cas du quatrième calcul qui lui soumet un vecteur.

::: callout-note

Dans les versions de R récentes, on peut utiliser la notation compacte `\(x) c(x, x, x)` à la place de `function(x) c(x, x, x)` pour désigner une fonction.

À l'intérieur de l'écosystème tidyverse, on peut également utiliser la notation très compacte `~c(.x, .x, .x)`.

:::

# vapply : une sorte de lapply mais avec une sortie sous forme d'un vecteur ou d'une matrice.

On l'a vu dans les exemples précédents, `lapply` renvoie tous les élements sous la forme d'une liste. Mais une liste n'est pas un objet très pratique à manipuler dans un un langage vectoriel ! la fonction `vapply` permet de retourner les résultats sous la forme d'un vecteur ou d'une matrice. La syntaxe est un peu particulière mais on s'y habitue vite !

```{webr-r}
vecteur <- vapply(list(3L, 7L, -1L), \(x) x + 1L, 0L)
print(vecteur)
print(typeof(vecteur))
print(class(vecteur))
```

`vapply` applique la fonction anonyme `\(x) x + 1L` sur chaque élément de la liste `list(3L, 7L, -1L)` et renvoie un vecteur de type similaire à `0L` (c'est-à-dire un `"integer"`)

```{webr-r}
vecteur <- vapply(list(3L, 7L, -1L), \(x) x + 1L, 133123128L)
print(vecteur)
print(typeof(vecteur))
print(class(vecteur))
```

Ce calcul est exactement similaire au précédent. Ce qui est mis en avant ici, c'est que seul le type du troisième argument (`FUN.VALUE`) importe, sa valeur n'a aucune importance. Ici, si on veut retourner un vecteur entier, n'importe quel entier de taille 1 fait l'affaire.

```{webr-r}
matrice <-
  vapply(
    c("a", "b", "c", "d"),
    \(x) c(x, x, x),
    c("", "", "")
  )
print(matrice)
print(typeof(matrice))
print(class(matrice))
```

Dans le cas où, comme ici, chaque *application unitaire* de la fonction utilisée retourne plusieurs valeurs, alors l'argument `FUN.VALUE` doit être un vecteur de même taille.

* L'application de `\(x) c(x, x, x)` sur `"a"` donne `c("a", "a", "a")`.
* L'application de `\(x) c(x, x, x)` sur `"b"` donne `c("b", "b", "b")`.
* L'application de `\(x) c(x, x, x)` sur `"c"` donne `c("c", "c", "c")`.
* L'application de `\(x) c(x, x, x)` sur `"d"` donne `c("d", "d", "d")`.

On attend bien trois objets de taille 3.

Par conséquent, l'objet en retour sera une *matrice* et non plus un vecteur. Comme dans le cas vectoriel, son type est déterminé par celui de `FUN.VALUE`.

```{webr-r}
matrice <-
  vapply(
    c("a", "b", "c", "d"),
    \(x) c(x, x, x),
    c("je", "suis", "arbitraire")
  )
print(matrice)
print(typeof(matrice))
print(class(matrice))
```

Là encore, on remarque que les valeurs de l'argument `FUN.VALUE` sont purement arbitraires. Seules sa longueur et son type importent.

```{webr-r}
vecteur <- sapply(list(3L, 7L, -1L), \(x) x + 1L)
print(vecteur)
print(typeof(vecteur))
print(class(vecteur))
```

Lorsque l'on veut faire vite dans la console et que l'on n'a pas le temps de réfléchir, un raccourci pour `vapply` existe sans la `FUN.VALUE`. La fonction `sapply` devine automatiquement les dimensions et le type requis. Utiliser un `vapply` explicite est cependant une meilleure pratique à l'intérieur d'un programme.

```{webr-r}
matrice <-
  sapply(
    c("a", "b", "c", "d"),
    \(x) c(x, x, x)
  )
print(matrice)
print(typeof(matrice))
print(class(matrice))
```

::: callout-warning

## sapply est plus laxiste que vapply

Essayer d'utiliser un `sapply` sur :

```{r}
#| eval: false
lapply(
  list(c("a", "b"),
       c("c", "d", "e"),
       c("f", "g")),
  function(x) c(x, x, x)
)
```

```{webr-r}
# Vous pouvez essayer ici.
```

Que se passe-t-il ? Pourquoi ? Peut-on résoudre ce problème avec un vapply ?

::: {.callout-tip collapse="true"}

## Réponse

La liste en entrée du `sapply` est une liste de vecteurs de tailles variables. On répète trois fois ses éléments. Les vecteurs en **sortie** seront donc de tailles variables également ; et c'est ce qui est rédhibitoire pour que le sapply puisse déterminer une dimension de matrice adéquate. Il laisse donc le résultat sous la forme d'une liste.

On ne peut pas résoudre ce problème structurel avec un `vapply`, mais vapply a le mérite d'être plus strict : il renverra une erreur si les valeurs ne sont pas de la dimension explicitement demandée.

:::

:::

## Map : appliquer une fonction multi-paramètres termes à termes

On a vu avec `lapply` comment appliquer une fonction sur chaque termes d'*une* liste ou d'un vecteur et retourner une liste. Cependant, parfois, un seul argument ne suffit pas, et l'on a envie d'appliquer une fonction terme à terme sur plusieurs listes ou vecteurs. La fonction `Map` remplit ce besoin.

```{webr-r}
Map(paste,
    c("a", "b", "c"),
    c("d", "e", "f"))
```

On voit ici que la fonction Map permet d'appliquer termet à terme la fonction paste sur deux vecteurs.

```{webr-r}
Map(paste,
    c("a", "b", "c"),
    c("d", "e", "f"),
    MoreArgs = list(sep = ""))
```

L'argument `MoreArgs` de `Map` permet de rajouter une liste d'arguments complémentaires, qui restent fixes entre tous les appels.

```{webr-r}
Map(\(x) paste(x, sep = ""),
    c("a", "b", "c"),
    c("d", "e", "f"))
```

On aurait aussi tout aussi pu utiliser une fonction anonyme pour spécifier des arguments complémentaires. C'est au choix !

```{webr-r}
Map(paste,
    c("a", "b", "c"),
    c("d", "e", "f"),
    c("g", "h", "i"))
```

La fonction `Map` peut utiliser autant d'arguments que l'on veut, dès lors que la fonction mappée est compatible avec ce nombre d'arguments.

```{webr-r}
Map(`+`,
    list(c(1L, 2L, 3L), c(4L, 5L, 6L, 7L), c(8L, 9L)),
    list(c(10L, 11L, 12L), c(13L, 14L, 15L, 16L), c(17L, 18L)))
```

La fonction `Map` peut tout-à-fait utiliser des listes. Ici, elle renvoie donc une liste appliquant la fonction `+` terme à terme :

* `c(1L, 2L, 3L) + c(10L, 11L, 12L)` pour le premier terme.
* `c(4L, 5L, 6L, 7L) + c(13L, 14L, 15L, 16L)` pour le deuxième terme.
* `c(8L, 9L) + c(17L, 18L)` pour le troisième terme.

## replicate : une variante commode de lapply pour les générations de nombres aléatoires

Certaines fonctions utiles en statistiques génèrent des nombres aléatoires. Par exemple, `runif(2L)` renvoie 2L nombres entre 0 et 1 selon une loi uniforme. Si on veut générer 4 vecteurs de 2 nombres aléatoires, on voudrait faire un lapply sur `function() runif(2L)`.

Le problème, c'est que cette fonction est sans paramètre. Du coup comment lui spécifier un `lapply` ?

```{webr-r}
lapply(rep(2L, 4L),
       function(n) runif(n))
```

L'astuce ci-dessus permet de résoudre le problème ; on a répété 4 fois le 2L. On applique ensuite donc `function(n) runif(n)` sur `c(2L, 2L, 2L, 2L)`. Chaque élément du vecteur renvoie alors un vecteur de deux nombres aléatoires. Ce n'est cependant pas des plus élégants.

```{webr-r}
replicate(4L, runif(2L), simplify = FALSE)
```

`replicate` permet d'évaluer une expression plusieurs fois de suite. Cela n'est, bien entendu, utile que dans le cas où cette expression renvoie des résultats différents à chaque évaluation, ce qui est notamment le cas dans le cas des générations de nombres aléatoires.

On note l'argument `simplify = FALSE` à la fin. Si celui-ci n'est pas spécifié, il est par défaut défini à la valeur `TRUE`, et alors replicate se comporte comme un `sapply` ; il essaye de construire des matrices.