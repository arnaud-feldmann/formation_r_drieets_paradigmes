---
title: "Programmation fonctionnelle objet en R (S3)"
webr:
  packages: ["dplyr", "disaggR"]
  autoload: false
---

## Introduction : S3 et la Programmation Orientée Objet

Comme on l'a vu dans la page d'introduction, S3 est un système de programmation orientée objet qui existe dans R, adapté par rapport aux autres langages pour être soluble au paradigme prédominant dans R, à savoir la programmation fonctionnelle.

Dans R, S3 est structuré par :

* des **fonction génériques** qui sont simplement des noms de fonctions munis d'une description abstraite en langage naturel. Par exemple `summary()` est une fonction générique. Sa description abstraite est décrite par l'aide accessible via `?summary`. On y lit "`summary` is a generic function used to produce result summaries of the results of various model fitting functions. The function invokes particular methods which depend on the class of the first argument.". Pour l'instant `summary()` n'est qu'une abstraction, elle n'a pas de code. À charge des différents concepteurs d'objets de lui donner un sens particulier, conforme à sa description abstraite.
* des **classes d'objets** qui sont simplement des étiquettes portées par l'objet et montrées à la fonction générique. Par exemple, si `objet` est un objet de classe `twoStepsBenchmark` du package [disaggR](https://github.com/InseeFr/disaggR), il montrera une étiquette `"twoStepsBenchmark"` à la fonction `summary()`. Un objet `tibble` montrera une étiquette `"tbl_df"` à la fonction `summary()` (`"tbl_df"` est le vrai nom de classe tibbles).
* des **méthodes** qui écrivent explicitement le code utilisé pour une fonction dans le cas d'une classe d'objet (on peut dire qu'on *implémente* `summary()` quand on en écrit explicitement son code pour une classe précise). Par exemple `summary()` renverra vers `summary.twoStepsBenchmark()` pour un objet de classe `twoStepsBenchmark`, tandis qu'elle essayera en premier de renvoyer vers `summary.tbl_df()` pour un tibble.
* Un **héritage** entre classes d'objets qui dit simplement que si une méthode n'existe pas pour une fonction générique, alors on en cherche une autre, puis une autre, et ainsi de suite. Par exemple un tibble a en fait 3 étiquettes, `c("tbl_df", "tbl", "data.frame")`. En ce qui concerne la fonction `summary()`, elle cherche d'abord une fonction `summary.tbl_df()` (qui n'existe pas), puis une fonction `summary.tbl()` (qui n'existe pas non plus), et enfin une fonction `summary.data.frame()` (qui existe ! Bingo ! C'est la méthode utilisée.).

Usuellement, un système de Programmation Orientée Objet structure le code en faisant appel à des *instances d'objets* sur lesquelles on appelle des *méthodes*. Plus spécifiquement, on a :

* Une **instance d'objet**, par exemple *la* baguette magique que j'ai en main en écrivant ces lignes.
* Une **classe d'objet**, par exemple celle des *baguettes magiques*. Toutes les instances de baguettes magiques se comportent exactement de la même manière, mais peuvent avoir différents attibuts (longueur, bois utilisé...).
* Des **méthodes**, à savoir les choses que l'on peut faire avec une classe d'objets. Par exemple en ce qui concerne les baguettes magiques, considérons `jeter_boule_de_feu()`, et `faire_pleuvoir()`.
* Un **héritage**, à savoir que chaque classe a une classe parente dont elle étend les possibilités. Une baguette magique est un type particulier de bâton de bois. La classe des "baguettes magiques" hérite de l'ensemble des méthodes des "bâtons de bois". On peut toujours `taper_sur_un_ennemi()`, `faire_un_feu_de_camp()`, `casser_en_deux()` avec une baguette magique.

On remarque que S3 préserve un peu cette structuration générale, mais l'adapte. Les éléments de POO sont tordus pour correspondre au paradigme prédominant qui est le paradigme fonctionnel. Voici les changements notables :

* On centre sur **les fonctions plutôt que les classes**. Au lieu de s'attarder sur une classe et de décrire les méthodes que l'on peut appliquer dessus, dans S3 on énonce un nom de fonction, mettons `faire_pleuvoir(objet)`, puis on ajoute `faire_pleuvoir.baguette_magique(objet)` qui est la méthode `faire_pleuvoir()` adaptée aux baguettes magiques. On peut ensuite ajouter également `faire_pleuvoir.robot_chanteur(objet)` si on veut prévoir une méthode pour les robots chanteurs.
* Il n'y a **pas de notion d'instance d'objet**. La notion d'instance d'objet induit une notion d'unicité (il n'y a qu'une seule baguette magique d'Harry Potter) et d'état interne (on a besoin d'états internes pour incrémenter, comme on l'a fait dans les chapitres précédents avec des closures). Si on casse la baguette magique d'Harry Potter en deux, c'est définitif. C'est une notion complexe, on l'abordera un peu plus en détail dans la suite.

## S3 en pratique

Pour voir les classes d'un objet, on utilise la fonction `class()`.

```{webr-r}
library(disaggR)
library(dplyr)
benchmark <- twoStepsBenchmark(turnover, construction)
print(class(benchmark)) # On ignorera ici ce qui est écrit sous attr(,"package")
print(class(dplyr::starwars))
```

On vérifie bien que :

* Un objet créé par `twoStepsBenchmark()` est de classe `"twoStepsBenchmark"`.
* Un tibble est de classe `"tbl_df"`, hérite de `"tbl"` et de `"data.frame"`.

On identifie une fonction générique S3 par le fait que son corps se limite à un `UseMethod("nom_de_la_fonction")`.

```{webr-r}
summary
```

Dans l'exemple ci-dessus, on voit que la fonction summary n'est définie par rien d'autre que :

```{r}
#| eval: false
summary <- function(object, ...) UseMethod("summary")
```

C'est assez succinct ! Cela déclare summary comme une fonction générique, et dit d'aller chercher la bonne méthode selon la classe du premier argument (ici `object`).

Pour voir les méthodes proposées par une fonction générique, on utilise `methods()` :

```{webr-r}
methods(summary)
```

Il y a un paquet de méthodes implémentées pour `summary()` dites-donc ! Certaines méthodes n'ont pas d'étoiles derrière leur nom. Pour consulter le code de l'une d'elle, il suffit de taper leur nom.

```{webr-r}
summary.data.frame
```

Ces méthodes correspondent à des fonctions *exportées* par les packages (ou par r-base). Elles peuvent très bien être utilisées telles quelles si on ne souhaite pas passer par la générique.

```{webr-r}
summary.data.frame(dplyr::starwars)
```

Certaines méthodes apparaissent avec une * après leur nom. Elles correspondent à des méthodes non-exportées par un package, c'est-à-dire que l'auteur du package n'a pas jugé utile de rendre directement disponible le nom de méthode à l'utilisateur et privilégie l'emploi de la générique. C'est aujourd'hui le comportement par défaut.

```{web-r}
library(disaggR)
benchmark <- twoStepsBenchmark(turnover, construction)
summary.twoStepsBenchmark(benchmark) # Renvoie une erreur car le nom summary.data.frame n'est pas exporté.
```

On peut toutefois lire ces méthodes et savoir d'où elles viennent en utilisant `getAnywhere()`.

```{web-r}
getAnywhere(summary.twoStepsBenchmark)
```

Ici, on lit que la méthode `summary.twoStepsBenchmark` existe de manière interne au package `disaggR`, et son code est :

```{r}
#| eval: false
summary.twoStepsBenchmark <- function (object, ...) {
    summary.praislm(prais(object), ...)
}
```

Autrement dit, elle renvoie encore à une autre méthode de `summary`.

::: callout-note

On peut accéder à toutes les fonctions non-exportées (fonctions internes) d'un package à l'aide des triples doubles-points (`:::`). Par exemple, on peut ici accéder à `summary.twoStepsBenchmark` en écrivant :

```{webr-r}
library(disaggR)
benchmark <- twoStepsBenchmark(turnover, construction)
disaggR:::summary.twoStepsBenchmark(benchmark)
```

Bien sûr, même si c'est utile à savoir pour comprendre le fonctionnement de R, inutile de vous prévenir que ce n'est pas une bonne pratique dans du code de production. R est très permissif, mais c'est à l'utilisateur de se discipliner. Les fonctions internes d'un package peuvent changer complètement d'une version à une autre sans prévenir l'utilisateur qui n'est normalement pas censé les utiliser directement.

:::

On peut également utiliser `methods()` pour chercher toutes les méthodes associées *directement* à une classe :

```{webr-r}
library(disaggR)
library(dplyr)
print(methods(class = "twoStepsBenchmark"))
print(methods(class = "tbl_df"))
print(methods(class = "tbl"))
print(methods(class = "data.frame"))
```

## Attributs