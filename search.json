[
  {
    "objectID": "fonctions.html",
    "href": "fonctions.html",
    "title": "Rappel sur les fonctions en R",
    "section": "",
    "text": "En R, on définit une fonction de cette manière :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLa fonction super_calcul a plusieurs paramètres : a, b et multiplication. On donne à ces paramètres des valeurs qu’on appelle arguments. Toutefois, dans le langage courant, et peut-être dans cette formation si je ne fais pas trop attention, on utilise parfois indistinctement les deux mots.\nOn remarque que le paramètre multiplication a un argument par défaut. Si on omet de lui donner une valeur, sa valeur par défaut sera TRUE.\nOn remarque aussi que, lorsque l’on fait des appels de fonctions, l’on peut choisir d’utiliser explicitement les noms des différents paramètres. Si on utilise les noms explicites, il est possible de les renseigner dans le désordre.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLe code ci-dessus renvoie une erreur. En effet, si un paramètre n’a pas de valeur par défaut, une valeur doit obligatoirement être assignée lors de l’appel de fonction.\n\n\n\n\n\n\nNote\n\n\n\nLa dernière remarque n’est pas complètement vraie. Du vieux code persiste dans R, renseignant des arguments par défaut dans le code même de la fonction, à l’aide de if (missing(argument)) {}. Ceci est toutefois, en général, considéré comme une mauvaise pratique.\n\n\nOn vient de constater de manière implicite un aspect de R : par défaut, la valeur retournée par une fonction est la dernière valeur évaluée lors de son exécution (qui dépend éventuellement de structures telles que if () else {}). Une manière explicite de renvoyer une valeur de retour est d’invoquer return(). Appeler return() met fin à l’exécution de la fonction. Tout ce qui vient après n’est jamais rappelé.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\ncalcula() renvoie 2L, tandis que calculb() renvoie 3L. On aurait pu également constater que, dans calcula, si on remplace 3L par stop(), le stop n’empêche pas la fonction de retourner convenablement. En effet, il arrive après le return.",
    "crumbs": [
      "Rappel sur les fonctions en R"
    ]
  },
  {
    "objectID": "fonctions.html#définition-de-fonction",
    "href": "fonctions.html#définition-de-fonction",
    "title": "Rappel sur les fonctions en R",
    "section": "",
    "text": "En R, on définit une fonction de cette manière :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLa fonction super_calcul a plusieurs paramètres : a, b et multiplication. On donne à ces paramètres des valeurs qu’on appelle arguments. Toutefois, dans le langage courant, et peut-être dans cette formation si je ne fais pas trop attention, on utilise parfois indistinctement les deux mots.\nOn remarque que le paramètre multiplication a un argument par défaut. Si on omet de lui donner une valeur, sa valeur par défaut sera TRUE.\nOn remarque aussi que, lorsque l’on fait des appels de fonctions, l’on peut choisir d’utiliser explicitement les noms des différents paramètres. Si on utilise les noms explicites, il est possible de les renseigner dans le désordre.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLe code ci-dessus renvoie une erreur. En effet, si un paramètre n’a pas de valeur par défaut, une valeur doit obligatoirement être assignée lors de l’appel de fonction.\n\n\n\n\n\n\nNote\n\n\n\nLa dernière remarque n’est pas complètement vraie. Du vieux code persiste dans R, renseignant des arguments par défaut dans le code même de la fonction, à l’aide de if (missing(argument)) {}. Ceci est toutefois, en général, considéré comme une mauvaise pratique.\n\n\nOn vient de constater de manière implicite un aspect de R : par défaut, la valeur retournée par une fonction est la dernière valeur évaluée lors de son exécution (qui dépend éventuellement de structures telles que if () else {}). Une manière explicite de renvoyer une valeur de retour est d’invoquer return(). Appeler return() met fin à l’exécution de la fonction. Tout ce qui vient après n’est jamais rappelé.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\ncalcula() renvoie 2L, tandis que calculb() renvoie 3L. On aurait pu également constater que, dans calcula, si on remplace 3L par stop(), le stop n’empêche pas la fonction de retourner convenablement. En effet, il arrive après le return.",
    "crumbs": [
      "Rappel sur les fonctions en R"
    ]
  },
  {
    "objectID": "fonctions.html#dots",
    "href": "fonctions.html#dots",
    "title": "Rappel sur les fonctions en R",
    "section": "Dots",
    "text": "Dots\nLorsque le nombre de paramètres d’une fonction peut être variable, on peut utiliser les ... qu’on appelle “dots”. list(...) permet de retrouver ces arguments sous forme de liste dans le corps de la fonction.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDans le code précédent, on a pu faire une fonction de somme sans figer à l’avance le nombre de termes de la somme.\n\n\n\n\n\n\nNote\n\n\n\nOn a utilisé dans super_somme une fonction particulière, Reduce, qui est typique des langages fonctionnels. L’idée est ici que l’on calcule 2 + 3 + 7 + 1. On verra plus en détail ce type d’opérations dans la partie dédiée au paradigme fonctionnel.\nDans le cas présent, sum existe déjà et peut déjà s’appliquer à un vecteur. On n’a écrit super_somme qu’à fin d’illustration.",
    "crumbs": [
      "Rappel sur les fonctions en R"
    ]
  },
  {
    "objectID": "fonctions.html#appeler-une-fonction-dots-sur-une-liste",
    "href": "fonctions.html#appeler-une-fonction-dots-sur-une-liste",
    "title": "Rappel sur les fonctions en R",
    "section": "Appeler une fonction dots sur une liste",
    "text": "Appeler une fonction dots sur une liste\nImaginons que l’on veuille appeler une fonction ... sur une liste. On souhaite que chaque élément de la liste devienne un argument. On peut par exemple faire, sur notre fonction super_somme.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nNote\n\n\n\nLa fonction do.call est en réalité plus générale que cela. Elle permet également d’utiliser des arguments nommés, comme on peut le voir dans l’exemple suivant :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Rappel sur les fonctions en R"
    ]
  },
  {
    "objectID": "fonctions.html#fonction-récursives",
    "href": "fonctions.html#fonction-récursives",
    "title": "Rappel sur les fonctions en R",
    "section": "Fonction récursives",
    "text": "Fonction récursives\nLes fonctions en R peuvent tout-à-fait être récursives. Par exemple, même si factorial() existe déjà dans R, on pourrait très bien la redéfinir via :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nR permet également une petite astuce pour éviter d’avoir à utiliser le nom d’une fonction dans son propre corps (cela permet de pouvoir renommer la fonction à un seul endroit). Le code précédent est équivalent à :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nRemarque optionnelle\n\n\n\nDepuis la dernière version de R (pas avant !), on peut utiliser la fonction Tailcall pour faire des récursivités terminales ; qui sont moins pratiques à lire mais plus efficaces. L’interface n’est pas encore figée mais cela ressemble aujourd’hui à cela.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Rappel sur les fonctions en R"
    ]
  },
  {
    "objectID": "fonctions.html#quizz",
    "href": "fonctions.html#quizz",
    "title": "Rappel sur les fonctions en R",
    "section": "Quizz",
    "text": "Quizz\nQuestion 1\nRéécrire la fonction super_somme en utilisant une syntaxe récursive. On pourra, par exemple, s’aider de la fonction head, qui permet de retourner une sous-liste contenant les n premiers éléments d’une liste.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\nsuper_somme &lt;- function(...) {\n  dots &lt;- list(...)\n  longueur &lt;- length(dots)\n  if (longueur == 0L) 0\n  else dots[[longueur]] + do.call(super_somme, head(dots, longueur - 1L))\n}\nprint(super_somme(2, 3, 7, 1))\n\n[1] 13\n\n\n\n\n\n\n\n\nRemarque\n\n\n\n\nLa récursivité est ici très bourrine ! On le fait juste pour l’exercice.\nQuelques petites astuces permettent, si besoin, d’éviter de convertir tous les arguments d’une fonction dots en liste. On dispose par exemple de ...length() en tant que substitut pour length(list(...)).\n\n\n\n\n\n\nQuestion 2\nEcrire une fonction ... super_produit qui calcule le produit de tous les arguments, et l’utiliser pour écrire une nouvelle version de la fonction fact.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\nsuper_produit &lt;- function(...) {\n  dots &lt;- list(...)\n  Reduce(`*`, dots)\n}\nfact &lt;- function(n) {\n  do.call(super_produit, as.list(1L:n))\n}\nfact(10)\n\n[1] 3628800\n\n\n\n\n\nQuestion 3\nEcrire une fonction dots usine_a_gaz qui renvoie :\n\nNULL s’il n’y a aucun argument.\nLe nombre d’arguments s’il y en a deux ou plus.\n\"bonjour\" si on lui soumet en unique argument un vecteur de type character.\nLa somme du vecteur si on lui soumet en unique argument un vecteur numérique au sens de is.numeric.\n\"échec\" dans tous les autres cas.\n\nOn pourra éventuellement s’aider des petites astuces, dont ...length(), lisibles dans la page d’aide des .... Celle-ci est accessible en tapant ?dots.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\nusine_a_gaz &lt;- function(...) {\n  longueur &lt;- ...length()\n  if (longueur == 0) NULL\n  else if (longueur &gt;= 2L) longueur\n  else if (is.character(..1)) \"bonjour\"\n  else if (is.numeric(..1)) sum(..1)\n  else \"échec\"\n}\nprint(usine_a_gaz())\n\nNULL\n\nprint(usine_a_gaz(1,3))\n\n[1] 2\n\nprint(usine_a_gaz(c(\"a\",\"b\")))\n\n[1] \"bonjour\"\n\nprint(usine_a_gaz(c(1, 2)))\n\n[1] 3\n\nprint(usine_a_gaz(c(1L, 2L)))\n\n[1] 3\n\nprint(usine_a_gaz(list()))\n\n[1] \"échec\"\n\n\nOn peut également utiliser des return(), auquel cas les else deviennent inutiles puisque return fait directement retourner la fonction.\n\nusine_a_gaz &lt;- function(...) {\n  longueur &lt;- ...length()\n  if (longueur == 0) return(NULL)\n  if (longueur &gt;= 2L) return(longueur)\n  if (is.character(..1)) return(\"bonjour\")\n  if (is.numeric(..1)) return(sum(..1))\n  \"échec\"\n}\nprint(usine_a_gaz())\n\nNULL\n\nprint(usine_a_gaz(1,3))\n\n[1] 2\n\nprint(usine_a_gaz(c(\"a\",\"b\")))\n\n[1] \"bonjour\"\n\nprint(usine_a_gaz(c(1, 2)))\n\n[1] 3\n\nprint(usine_a_gaz(c(1L, 2L)))\n\n[1] 3\n\nprint(usine_a_gaz(list()))\n\n[1] \"échec\"",
    "crumbs": [
      "Rappel sur les fonctions en R"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction : les paradigmes de programmation",
    "section": "",
    "text": "Un paradigme de programmation peut être vu comme la philosophie d’un langage. Il prédétermine une manière d’écrire propre à celui-ci, influence ses possibilités, définit une idiomatique conventionnelle (c’est-à-dire, par exemple, une manière d’éviter de copier-coller 500 fois le même paragraphe). Ces paradigmes sont des archétypes ; en réalité, les langages modernes permettent souvent plusieurs paradigmes. Ceux-ci ne correspondent donc pas à une sorte de réglement implacable mais énoncent plutôt différentes manières de structurer du code. Ce qui importe, au fond, c’est d’être suffisamment avisé pour pouvoir faire des choix.\nTrois principaux paradigmes dominent le monde actuel de la programmation. La programmation procédurale, la programmation objet, et la programmation fonctionnelle (cette dernière est le paradigme principal de R).",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#paradigmes-de-programmation",
    "href": "index.html#paradigmes-de-programmation",
    "title": "Introduction : les paradigmes de programmation",
    "section": "",
    "text": "Un paradigme de programmation peut être vu comme la philosophie d’un langage. Il prédétermine une manière d’écrire propre à celui-ci, influence ses possibilités, définit une idiomatique conventionnelle (c’est-à-dire, par exemple, une manière d’éviter de copier-coller 500 fois le même paragraphe). Ces paradigmes sont des archétypes ; en réalité, les langages modernes permettent souvent plusieurs paradigmes. Ceux-ci ne correspondent donc pas à une sorte de réglement implacable mais énoncent plutôt différentes manières de structurer du code. Ce qui importe, au fond, c’est d’être suffisamment avisé pour pouvoir faire des choix.\nTrois principaux paradigmes dominent le monde actuel de la programmation. La programmation procédurale, la programmation objet, et la programmation fonctionnelle (cette dernière est le paradigme principal de R).",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#la-programmation-procédurale",
    "href": "index.html#la-programmation-procédurale",
    "title": "Introduction : les paradigmes de programmation",
    "section": "La programmation procédurale",
    "text": "La programmation procédurale\nLa programmation procédurale est le plus ancien paradigme de programmation. Il s’agit d’une séquence de procédures, c’est-à-dire une série d’étapes à réaliser pour faire quelque chose. On peut voir cela comme une recette de cuisine.\nSupposons que l’on veuille peindre un mur en vert, on pourrait faire :\n\nmettre_sur_palette(palette, bleu)\nmettre_sur_palette(palette, jaune)\nmélanger_couleurs_sur_palette(palette)\npeindre_mur(mur, palette[3])\n\nIl faut bien noter ce qui se passe à la fin de la dernière ligne : on a sélectionné la couleur de la palette en appelant son emplacement numéro 3 avec palette[3]. Cela suppose d’une part que l’on connait le fonctionnement interne des palettes, et d’autre part que cette structure interne ne change jamais. Si l’on change le code interne de la palette, il faudra aussi changer notre code. Notre programme dépend de l’implémentation de la palette.\nToutefois, la programmation purement procédurale n’est pas sans intérêt dans les langages proches du matériel (on les appelle “de bas niveau”). Elle est par exemple utilisée dans le langage C. Le véritable langage des machines est en effet en lui-même procédural ; un processeur est essentiellement un composant électronique qui manipule des états de manière séquentielle. La programmation procédurale pour autant pas restreinte aux langages de bas-niveau ; Python notamment est un peu fourre-tout, mais reste relativement procédural.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#la-programmation-orientée-objet-poo",
    "href": "index.html#la-programmation-orientée-objet-poo",
    "title": "Introduction : les paradigmes de programmation",
    "section": "La programmation orientée objet (POO)",
    "text": "La programmation orientée objet (POO)\nLa programmation orientée objet a émergé du besoin de faire apparaître une syntaxe disciplinée et plus proche d’une perception humaine. Pour ce faire, on s’inspire du monde réel : il n’y a pas besoin de connaitre le fonctionnement électronique d’une télécommande pour appuyer sur ses boutons. Il est pas attendu non plus que l’utilisateur d’une télévision aille bidouiller ses circuits imprimés pour s’en servir. Dans un langage objet, l’exemple précédent pourrait s’écrire :\n\npalette.ajouter(bleu)\npalette.ajouter(jaune)\npalette.mélanger()\nmur.peindre(palette.get_couleur())\n\nOn voit que palette, une instance de palette, possède a minima trois méthodes (ajouter, mélanger, et get_couleur). Puisqu’on s’est astreints à ne jamais accéder aux états internes de la palette, on a découplé le programme de peinture de celui des palettes. On n’a plus besoin de savoir comment est structurée intérieurement une palette (on ne sélectionne plus son 3ème élément). La différence est de taille : la personne qui s’occupe de la maintenance des palettes peut maintenant les changer comme elle veut sans risquer de causer une erreur dans le programme de peinture (par exemple un mur jaune fluo à poids mauves). La seule chose qui doit être respectée, c’est le comportement des différentes méthodes.\n\n\n\n\n\n\nNote\n\n\n\nJava et C++ sont des langages objet populaires.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#la-programmation-fonctionnelle",
    "href": "index.html#la-programmation-fonctionnelle",
    "title": "Introduction : les paradigmes de programmation",
    "section": "La programmation fonctionnelle",
    "text": "La programmation fonctionnelle\nLà où la POO s’inspire des objets dans le monde réel, la programmation fonctionnelle s’inspire du monde des mathématiques. L’idée fondamentale de la programmation fonctionnelle est de ne plus manipuler d’états ; on n’utilise que ce qu’on appelle des “fonctions pures”. Celles-ci se comportent comme une calculatrice sans mémoire. Elles font un calcul purement combinatoire ; elles sont prévues pour retourner toujours le même résultat à partir des mêmes entrées.\n\nmur = mur_peint(couleur = mélanger(jaune, bleu))\n\nLa syntaxe fonctionnelle étant proche d’une écriture mathématique, elle convient aux langages de haut niveau prévus pour le calcul scientifique, comme R. Pendant longtemps (jusqu’aux années 2010), ce paradigme a été considéré comme assez académique et réservé aux profs de facs. Depuis les années 2010, cependant, le paradigme fonctionnel a rencontré un très net regain de popularité et est sorti des universités. Ses principaux intérêts sont :\n\nla grande facilité de déboggage et de test (une entrée doit toujours retourner la même sortie)\nla beauté/maintenabilité du code\nla forte parallélisabilité des calculs : les résultats ne dépendant que de leurs entrées, il est potentiellement possible de calculer plusieurs choses en même temps si l’on dispose de plusieurs CPU. C’est notamment cet aspect qui permet par exemple au package arrow d’être extrêmement rapide ; les calculs sont faits de manière possiblement concourrante plutôt que consécutive.\n\n\n\n\n\n\n\nNote\n\n\n\nOutre R, Haskell, Scala et Lisp sont des langages fonctionnels.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#r-un-langage-fonctionnel-vectoriel-avec-quelques-éléments-de-poo",
    "href": "index.html#r-un-langage-fonctionnel-vectoriel-avec-quelques-éléments-de-poo",
    "title": "Introduction : les paradigmes de programmation",
    "section": "R : un langage fonctionnel, vectoriel, avec quelques éléments de POO",
    "text": "R : un langage fonctionnel, vectoriel, avec quelques éléments de POO\nR est très majoritairement un langage fonctionnel. Dans la mesure où aucun langage n’est entièrement soluble dans un paradigme, il présente également quelques petits traits de programmation objet tordus pour correspondre au coeur d’un langage fonctionnel. Le principal système de programmation objet en R, S3 (qui n’a rien à voir avec le protocole de stockage même s’il s’appelle pareil), adapte les principes de la POO dans le contexte de la programmation fonctionnelle. Grosso modo, dans R, on définit des classes d’objets de manière beaucoup moins formelle que dans la POO (par exemple des tibble, des ggplot…), et on applique des fonctions pures dessus. Contrairement à ce qu’il se passe dans un langage POO, les objets de R sont immutables.\nD’accord, mais qu’est-ce que l’immutabilité ?\nDans presque tous les langages de programmation objet, si on fait :\n\nmur_a = nouveau_mur()\nmur_a.peindre(rouge)\nmur_b = mur_a\nmur_b.peindre(vert)\nmur_a.get_couleur() –&gt; renvoie vert\nmur_b.get_couleur() –&gt; renvoie vert\n\nLa couleur de mur_a a aussi changé ! En fait, dans un langage de POO, on crée des instances avec un constructeur (ici nouveau_mur). mur_a et mur_b correspondent au même mur. Si on modifie l’un, on modifie l’autre.\nA contrario, dans R, on aura plutôt :\n\nmur_a = nouveau_mur()\nmur_a.peindre(rouge)\nmur_b = mur_a\nmur_b.peindre(vert)\nmur_a.get_couleur() –&gt; renvoie rouge\nmur_b.get_couleur() –&gt; renvoie vert\n\nDans R, en fait, tout se passe comme si on ne manipulait que des valeurs, même quand on manipule des objets. On ne crée pas vraiment d’instances de murs.\nUn autre aspect particulier de R est qu’il est vectoriel. Si je fais :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLa vectorisation est tout-à-fait implicite. Dans un langage procédural non-vectorisé, j’aurais plutôt écrit :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nCette dernière écriture est équivalente mais n’est pas très pratique pour écrire des statistiques….\n\n\n\n\n\n\nNote\n\n\n\nL’opérateur pipe %&gt;% repose sur les axiomes de la programmation fonctionnelle. Il suppose en effet que chaque sortie de fonction ne dépend que des entrées. Il permet de profiter à la fois de la simplicité d’une écriture de type “recette de cuisine” et des avantages de la programmation fonctionnelle.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#quizz",
    "href": "index.html#quizz",
    "title": "Introduction : les paradigmes de programmation",
    "section": "Quizz",
    "text": "Quizz\nQuestion 1\n\nDans un langage fonctionnel idéal :\n\n\n\n\n ✗On n’utilise que des procédures (des fonctions sans valeur de retour).\n\n\n ✓On n’utilise que des fonctions dites pures, c’est-à-dire des fonctions purement combinatoires.\n\n\n ✗On n’utilise que des fonctions, pures, ou non.\n\n\n ✗Différentes étapes successives qu’on appelle fonctions. On les applique sur des objets qu’elles modifient progressivement.\n\n\n\n\n\nQuestion 2\n\nQuel est le rapport entretenu entre R et la Programmation Orientée Objet ?\n\n\n\n\n ✗R est un archétype de langage de POO.\n\n\n ✗On ne peut pas du tout faire de POO en R.\n\n\n ✗Objection votre honneur !\n\n\n ✓R est surtout un langage fonctionnel, mais il présente quelques aspects de POO.\n\n\n\n\n\nQuestion 3\n\nUn langage de bas niveau est un langage caractérisé par sa simplicité.\n\n\n\n\n ✓Non, c’est un langage proche du langage machine, donc souvent assez complexe et verbieux.\n\n\n ✗Exactement ! C’est un langage prévu pour être facile d’appréhension, d’où de “bas niveau”.\n\n\n ✗Non, un langage de bas-niveau est un langage est un langage qui est calculé dans la partie basse des microprocesseurs, tandis que les langages de haut niveau sont déterminés par la partie haute.\n\n\n ✗Non, un langage de bas-niveau est un langage stromosogomique de capacitance inférimitésimale.\n\n\n\n\n\nQuestion 4\n\nAnalysons ce pseudo-code :\n\nclasseur_ods = nouveau_classeur_ods()\nonglet = nouvel_onglet(donnee = “En voilà de la donnée”)\nclasseur_ods.ajouter_onglet(onglet)\nclasseur_ods.enregistrer(“/home/tintin/mon_classeur.ods”)\n\nÀ quel paradigme de programmation cela ressemble ?\n\n\n\n\n ✗Langage procédural\n\n\n ✓Langage objet\n\n\n ✗Langage fonctionnel\n\n\n\n\n\nQuestion 5\n\nAnalysons ce pseudo-code :\n\na = [‘b’, ‘o’, ‘n’, ‘j’, ‘o’, ‘u’, ‘r’, ’ ’]\ni = 1\nwhile a[i] != ’ ’ {\n  print(a[i])\n  print(a[i])\n}\n\nÀ quel paradigme de programmation cela ressemble ?\n\n\n\n\n ✓Langage procédural\n\n\n ✗Langage objet\n\n\n ✗Langage fonctionnel\n\n\n\n\n\nQuestion 6\n\nAnalysons ce pseudo-code :\n\nracine_carrée(multiplier_par(entiers de 1 à 10, 3))\n\nÀ quel paradigme de programmation cela ressemble ?\n\n\n\n\n ✗Langage procédural\n\n\n ✗Langage objet\n\n\n ✓Un langage fonctionnel ! Et vectoriel en plus ! C’est presque R !\n\n\n\n\n\nQuestion 7\n\nOn a vu qu’un langage objet permet notamment d’éviter les dépendances à l’implémentation.\nOn préfère écrire :\n\nmur.peindre(palette.get_couleur())\n\nQue :\n\npeindre_mur(mur, palette[3])\n\nQuel intérêt cela présente ?\n\n\n\n\n ✗Aucun, c’est purement esthétique.\n\n\n ✓Cela permet à un collègue d’être libre de modifier le fonctionnement interne de la palette sans faire bugger le programme de peinture.\n\n\n ✗Compter jusqu’à 3 est difficile car un ordinateur repose sur des nombres binaires. On préfère donc enlever le 3.\n\n\n ✗On a vraiment envie que le programme de peinture dépende du programme de la palette. Il faut que les gens travaillent en équipe et donc qu’ils soient chacun au courant de tout ce qu’il se passe dans l’intégralité du projet.\n\n\n\n\n\nQuestion 8\n\nCombien de méthodes différentes de la classe discman ce pseudo-code utilise-t-il ?\n\ndiscman.brancher_ecouteurs(ecouteurs)\ndiscman.inserer_cd(never_mind_the_bollocks_here_s_the_sex_pistols)\ndiscman.ecouter_cd()\ndiscman.retirer_cd()\ndiscman.inserer_cd(peace_sells_but_who_s_buying)\ndiscman.ecouter_cd()\ndiscman.retirer_cd()\n\n\n\n\n\n ✗1\n\n\n ✗2\n\n\n ✗3\n\n\n ✓4\n\n\n ✗5\n\n\n ✗6\n\n\n ✗7",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "fonctions_manipulant_des_fonctions.html",
    "href": "fonctions_manipulant_des_fonctions.html",
    "title": "Fonctions manipulant des fonctions",
    "section": "",
    "text": "On a vu dans le point précédent deux fonctions qui s’appliquent sur des fonctions. do.call nous a permis d’appliquer une fonction ... sur une liste, tandis que Reduce nous a permis d’écrire 2 + 3 + 7 + 1 de manière un peu plus jolie qu’à la main.\nOn a vu aussi que R est un langage principalement fonctionnel. En fait, R offre un certain nombre de fonctions permettant d’appliquer des fonctions de différentes manières. Nous verrons ici lapply, vapply, Map, replicate, apply, do.call, Reduce.",
    "crumbs": [
      "Fonctions manipulant des fonctions"
    ]
  },
  {
    "objectID": "fonctions_manipulant_des_fonctions.html#manipuler-des-fonctions-avec-des-fonctions",
    "href": "fonctions_manipulant_des_fonctions.html#manipuler-des-fonctions-avec-des-fonctions",
    "title": "Fonctions manipulant des fonctions",
    "section": "",
    "text": "On a vu dans le point précédent deux fonctions qui s’appliquent sur des fonctions. do.call nous a permis d’appliquer une fonction ... sur une liste, tandis que Reduce nous a permis d’écrire 2 + 3 + 7 + 1 de manière un peu plus jolie qu’à la main.\nOn a vu aussi que R est un langage principalement fonctionnel. En fait, R offre un certain nombre de fonctions permettant d’appliquer des fonctions de différentes manières. Nous verrons ici lapply, vapply, Map, replicate, apply, do.call, Reduce.",
    "crumbs": [
      "Fonctions manipulant des fonctions"
    ]
  },
  {
    "objectID": "fonctions_manipulant_des_fonctions.html#lapply-appliquer-une-fonction-à-chaque-élément-dune-liste-ou-dun-vecteur",
    "href": "fonctions_manipulant_des_fonctions.html#lapply-appliquer-une-fonction-à-chaque-élément-dune-liste-ou-dun-vecteur",
    "title": "Fonctions manipulant des fonctions",
    "section": "lapply : appliquer une fonction à chaque élément d’une liste ou d’un vecteur",
    "text": "lapply : appliquer une fonction à chaque élément d’une liste ou d’un vecteur\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLa fonction function(x) c(x, x, x) demande à répéter trois fois un élément. Cette fonction est appliquée terme à terme à chaque élement de la liste.\n\nc(\"a\", \"b\") donne c(\"a\", \"b\", \"a\", \"b\", \"a\", \"b\")\nc(\"c\", \"d\", \"e\") donne c(\"c\", \"d\", \"e\", \"c\", \"d\", \"e\", \"c\", \"d\", \"e\")\nc(\"f\", \"g\") donne c(\"f\", \"g\", \"f\", \"g\", \"f\", \"g\")\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLe calcul ci-dessus montre qu’on peut utiliser lapply à l’intérieur d’une autre fonction.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nCe calcul illustre un aspect implicite des deux précédentes syntaxes utilisées : celles-ci utilisent function(x) c(x, x, x) en lieu et place d’un nom de fonction à l’intérieur du lapply ! On appelle cela des fonctions anonymes. Si une fonction n’a pour vocation que d’être utilisée une seule fois, cela peut rendre la syntaxe plus claire et plus élégante qu’une fonction nommée.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDans ce dernier calcul, on remarque que l’on peut appliquer lapply sur un vecteur.\nDans les 4 calculs, on se rend compte que le résultat de lapply est une liste. lapply retourne en effet une liste même dans le cas du quatrième calcul qui lui soumet un vecteur.\n\n\n\n\n\n\nNote\n\n\n\nDans les versions de R récentes, on peut utiliser la notation compacte \\(x) c(x, x, x) à la place de function(x) c(x, x, x) pour désigner une fonction.\nÀ l’intérieur de l’écosystème tidyverse, on peut également utiliser la notation très compacte ~c(.x, .x, .x).",
    "crumbs": [
      "Fonctions manipulant des fonctions"
    ]
  },
  {
    "objectID": "fonctions_manipulant_des_fonctions.html#map-appliquer-une-fonction-multi-paramètres-termes-à-termes",
    "href": "fonctions_manipulant_des_fonctions.html#map-appliquer-une-fonction-multi-paramètres-termes-à-termes",
    "title": "Fonctions manipulant des fonctions",
    "section": "Map : appliquer une fonction multi-paramètres termes à termes",
    "text": "Map : appliquer une fonction multi-paramètres termes à termes\nOn a vu avec lapply comment appliquer une fonction sur chaque termes d’une liste ou d’un vecteur et retourner une liste. Cependant, parfois, un seul argument ne suffit pas, et l’on a envie d’appliquer une fonction terme à terme sur plusieurs listes ou vecteurs. La fonction Map remplit ce besoin.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nOn voit ici que la fonction Map permet d’appliquer termet à terme la fonction paste sur deux vecteurs.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nL’argument MoreArgs de Map permet de rajouter une liste d’arguments complémentaires, qui restent fixes entre tous les appels.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nOn aurait aussi tout aussi pu utiliser une fonction anonyme pour spécifier des arguments complémentaires. C’est au choix !\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLa fonction Map peut utiliser autant d’arguments que l’on veut, dès lors que la fonction mappée est compatible avec ce nombre d’arguments.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLa fonction Map peut tout-à-fait utiliser des listes. Ici, elle renvoie donc une liste appliquant la fonction + terme à terme :\n\nc(1L, 2L, 3L) + c(10L, 11L, 12L) pour le premier terme.\nc(4L, 5L, 6L, 7L) + c(13L, 14L, 15L, 16L) pour le deuxième terme.\nc(8L, 9L) + c(17L, 18L) pour le troisième terme.",
    "crumbs": [
      "Fonctions manipulant des fonctions"
    ]
  },
  {
    "objectID": "fonctions_manipulant_des_fonctions.html#replicate-une-variante-commode-de-lapply-pour-les-générations-de-nombres-aléatoires",
    "href": "fonctions_manipulant_des_fonctions.html#replicate-une-variante-commode-de-lapply-pour-les-générations-de-nombres-aléatoires",
    "title": "Fonctions manipulant des fonctions",
    "section": "replicate : une variante commode de lapply pour les générations de nombres aléatoires",
    "text": "replicate : une variante commode de lapply pour les générations de nombres aléatoires\nCertaines fonctions utiles en statistiques génèrent des nombres aléatoires. Par exemple, runif(2L) renvoie 2L nombres entre 0 et 1 selon une loi uniforme. Si on veut générer 4 vecteurs de 2 nombres aléatoires, on voudrait faire un lapply sur function() runif(2L).\nLe problème, c’est que cette fonction est sans paramètre. Du coup comment lui spécifier un lapply ?\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nL’astuce ci-dessus permet de résoudre le problème ; on a répété 4 fois le 2L. On applique ensuite donc function(n) runif(n) sur c(2L, 2L, 2L, 2L). Chaque élément du vecteur renvoie alors un vecteur de deux nombres aléatoires. Ce n’est cependant pas des plus élégants.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nreplicate est une variante de lapply qui permet d’évaluer une expression plusieurs fois de suite. Cela n’est, bien entendu, utile que dans le cas où cette expression renvoie des résultats différents à chaque évaluation, ce qui est notamment le cas en ce qui concerne la générations de nombres aléatoires.\nOn note l’argument simplify = FALSE à la fin. Si celui-ci n’est pas spécifié, il est par défaut défini à la valeur TRUE, et alors replicate se comporte comme un sapply ; il essaye de construire des matrices.",
    "crumbs": [
      "Fonctions manipulant des fonctions"
    ]
  },
  {
    "objectID": "fonctions_manipulant_des_fonctions.html#apply-appliquer-une-fonction-sur-les-colonnes-ou-les-lignes-dune-matrice",
    "href": "fonctions_manipulant_des_fonctions.html#apply-appliquer-une-fonction-sur-les-colonnes-ou-les-lignes-dune-matrice",
    "title": "Fonctions manipulant des fonctions",
    "section": "apply : appliquer une fonction sur les colonnes ou les lignes d’une matrice",
    "text": "apply : appliquer une fonction sur les colonnes ou les lignes d’une matrice\napply permet d’appliquer une fonction par ligne ou par colonne.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDans le tronçon de code ci-dessus, on a appliqué la fonction max (maximum) respectivement sur chaque ligne et chaque colonne. C’est l’argument MARGIN en deuxième position qui permet de déterminer la direction de cette application de fonction (1 pour les lignes, 2 pour les colonnes).\n\n\n\n\n\n\nNote\n\n\n\nIl est à noter que quelques optimisations de ces fonctions existent. rowSums, colSums, rowMeans, colMeans ont toutes les quatre des noms assez parlants qui permettent d’éviter une écriture un peu trop poussive.",
    "crumbs": [
      "Fonctions manipulant des fonctions"
    ]
  }
]