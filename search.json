[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction : les paradigmes de programmation",
    "section": "",
    "text": "Un paradigme de programmation peut être vu comme la philosophie d’un langage. Il prédétermine une manière d’écrire propre à celui-ci, influence ses possibilités, définit une idiomatique conventionnelle (c’est-à-dire, par exemple, une manière d’éviter de copier-coller 500 fois le même paragraphe). Ces paradigmes sont des archétypes ; en réalité, les langages modernes permettent souvent plusieurs paradigmes. Ceux-ci ne correspondent donc pas à une sorte de réglement implacable mais énoncent plutôt différentes manières de structurer du code. Ce qui importe, au fond, c’est d’être suffisamment avisé pour pouvoir faire des choix.\nTrois principaux paradigmes dominent le monde actuel de la programmation. La programmation procédurale, la programmation objet, et la programmation fonctionnelle (cette dernière est le paradigme principal de R).",
    "crumbs": [
      "Paradigmes de programmation"
    ]
  },
  {
    "objectID": "index.html#paradigmes-de-programmation",
    "href": "index.html#paradigmes-de-programmation",
    "title": "Introduction : les paradigmes de programmation",
    "section": "",
    "text": "Un paradigme de programmation peut être vu comme la philosophie d’un langage. Il prédétermine une manière d’écrire propre à celui-ci, influence ses possibilités, définit une idiomatique conventionnelle (c’est-à-dire, par exemple, une manière d’éviter de copier-coller 500 fois le même paragraphe). Ces paradigmes sont des archétypes ; en réalité, les langages modernes permettent souvent plusieurs paradigmes. Ceux-ci ne correspondent donc pas à une sorte de réglement implacable mais énoncent plutôt différentes manières de structurer du code. Ce qui importe, au fond, c’est d’être suffisamment avisé pour pouvoir faire des choix.\nTrois principaux paradigmes dominent le monde actuel de la programmation. La programmation procédurale, la programmation objet, et la programmation fonctionnelle (cette dernière est le paradigme principal de R).",
    "crumbs": [
      "Paradigmes de programmation"
    ]
  },
  {
    "objectID": "index.html#la-programmation-procédurale",
    "href": "index.html#la-programmation-procédurale",
    "title": "Introduction : les paradigmes de programmation",
    "section": "La programmation procédurale",
    "text": "La programmation procédurale\nLa programmation procédurale est le plus ancien paradigme de programmation. Il s’agit d’une séquence de procédures, c’est-à-dire une série d’étapes à réaliser pour faire quelque chose. On peut voir cela comme une recette de cuisine.\nSupposons que l’on veuille peindre un mur en vert, on pourrait faire :\n\nmettre_sur_palette(palette, bleu)\nmettre_sur_palette(palette, jaune)\nmélanger_couleurs_sur_palette(palette)\npeindre_mur(mur, palette[3])\n\nIl faut bien noter ce qui se passe à la fin de la dernière ligne : on a sélectionné la couleur de la palette en appelant son emplacement numéro 3 avec palette[3]. Cela suppose d’une part que l’on connait le fonctionnement interne des palettes, et d’autre part que cette structure interne ne change jamais. Si l’on change le code interne de la palette, il faudra aussi changer notre code. Notre programme dépend de l’implémentation de la palette.\nToutefois, la programmation purement procédurale n’est pas sans intérêt dans les langages proches du matériel (on les appelle “de bas niveau”). Elle est par exemple utilisée dans le langage C. Le véritable langage des machines est en effet en lui-même procédural ; un processeur est essentiellement un composant électronique qui manipule des états de manière séquentielle. La programmation procédurale pour autant pas restreinte aux langages de bas-niveau ; Python notamment est un peu fourre-tout, mais reste relativement procédural.",
    "crumbs": [
      "Paradigmes de programmation"
    ]
  },
  {
    "objectID": "index.html#la-programmation-orientée-objet-poo",
    "href": "index.html#la-programmation-orientée-objet-poo",
    "title": "Introduction : les paradigmes de programmation",
    "section": "La programmation orientée objet (POO)",
    "text": "La programmation orientée objet (POO)\nLa programmation orientée objet a émergé du besoin de faire apparaître une syntaxe disciplinée et plus proche d’une perception humaine. Pour ce faire, on s’inspire du monde réel : il n’y a pas besoin de connaitre le fonctionnement électronique d’une télécommande pour appuyer sur ses boutons. Il est pas attendu non plus que l’utilisateur d’une télévision aille bidouiller ses circuits imprimés pour s’en servir. Dans un langage objet, l’exemple précédent pourrait s’écrire :\n\npalette.ajouter(bleu)\npalette.ajouter(jaune)\npalette.mélanger()\nmur.peindre(palette.get_couleur())\n\nOn voit que palette, une instance de palette, possède a minima trois méthodes (ajouter, mélanger, et get_couleur). Puisqu’on s’est astreints à ne jamais accéder aux états internes de la palette, on a découplé le programme de peinture de celui des palettes. On n’a plus besoin de savoir comment est structurée intérieurement une palette (on ne sélectionne plus son 3ème élément). La différence est de taille : la personne qui s’occupe de la maintenance des palettes peut maintenant les changer comme elle veut sans risquer de causer une erreur dans le programme de peinture (par exemple un mur jaune fluo à poids mauves). La seule chose qui doit être respectée, c’est le comportement des différentes méthodes.\n\n\n\n\n\n\nNote\n\n\n\nJava et C++ sont des langages objet populaires.",
    "crumbs": [
      "Paradigmes de programmation"
    ]
  },
  {
    "objectID": "index.html#la-programmation-fonctionnelle",
    "href": "index.html#la-programmation-fonctionnelle",
    "title": "Introduction : les paradigmes de programmation",
    "section": "La programmation fonctionnelle",
    "text": "La programmation fonctionnelle\nLà où la POO s’inspire des objets dans le monde réel, la programmation fonctionnelle s’inspire du monde des mathématiques. L’idée fondamentale de la programmation fonctionnelle est de ne plus manipuler d’états ; on n’utilise que ce qu’on appelle des “fonctions pures”. Celles-ci se comportent comme une calculatrice sans mémoire. Elles font un calcul purement combinatoire ; elles sont prévues pour retourner toujours le même résultat à partir des mêmes entrées.\n\nmur = mur_peint(couleur = mélanger(jaune, bleu))\n\nLa syntaxe fonctionnelle étant proche d’une écriture mathématique, elle convient aux langages de haut niveau prévus pour le calcul scientifique, comme R. Pendant longtemps (jusqu’aux années 2010), ce paradigme a été considéré comme assez académique et réservé aux profs de facs. Depuis les années 2010, cependant, le paradigme fonctionnel a rencontré un très net regain de popularité et est sorti des universités. Ses principaux intérêts sont :\n\nla grande facilité de déboggage et de test (une entrée doit toujours retourner la même sortie)\nla beauté/maintenabilité du code\nla forte parallélisabilité des calculs : les résultats ne dépendant que de leurs entrées, il est potentiellement possible de calculer plusieurs choses en même temps si l’on dispose de plusieurs CPU. C’est notamment cet aspect qui permet par exemple au package arrow d’être extrêmement rapide ; les calculs sont faits de manière possiblement concourrante plutôt que consécutive.\n\n\n\n\n\n\n\nNote\n\n\n\nOutre R, Haskell, Scala et Lisp sont des langages fonctionnels.",
    "crumbs": [
      "Paradigmes de programmation"
    ]
  },
  {
    "objectID": "index.html#r-un-langage-fonctionnel-vectoriel-avec-quelques-éléments-de-poo",
    "href": "index.html#r-un-langage-fonctionnel-vectoriel-avec-quelques-éléments-de-poo",
    "title": "Introduction : les paradigmes de programmation",
    "section": "R : un langage fonctionnel, vectoriel, avec quelques éléments de POO",
    "text": "R : un langage fonctionnel, vectoriel, avec quelques éléments de POO\nR est très majoritairement un langage fonctionnel. Dans la mesure où aucun langage n’est entièrement soluble dans un paradigme, il présente également quelques petits traits de programmation objet tordus pour correspondre au coeur d’un langage fonctionnel. Le principal système de programmation objet en R, S3 (qui n’a rien à voir avec le protocole de stockage même s’il s’appelle pareil), adapte les principes de la POO dans le contexte de la programmation fonctionnelle. Grosso modo, dans R, on définit des classes d’objets de manière beaucoup moins formelle que dans la POO (par exemple des tibble, des ggplot…), et on applique des fonctions pures dessus. Contrairement à ce qu’il se passe dans un langage POO, les objets de R sont immutables.\nD’accord, mais qu’est-ce que l’immutabilité ?\nDans presque tous les langages de programmation objet, si on fait :\n\nmur_a = nouveau_mur()\nmur_a.peindre(rouge)\nmur_b = mur_a\nmur_b.peindre(vert)\nmur_a.get_couleur() –&gt; renvoie vert\nmur_b.get_couleur() –&gt; renvoie vert\n\nLa couleur de mur_a a aussi changé ! En fait, dans un langage de POO, on crée des instances avec un constructeur (ici nouveau_mur). mur_a et mur_b correspondent au même mur. Si on modifie l’un, on modifie l’autre.\nA contrario, dans R, on aura plutôt :\n\nmur_a = nouveau_mur()\nmur_a.peindre(rouge)\nmur_b = mur_a\nmur_b.peindre(vert)\nmur_a.get_couleur() –&gt; renvoie rouge\nmur_b.get_couleur() –&gt; renvoie vert\n\nDans R, en fait, tout se passe comme si on ne manipulait que des valeurs, même quand on manipule des objets. On ne crée pas vraiment d’instances de murs.\nUn autre aspect particulier de R est qu’il est vectoriel. Si je fais :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLa vectorisation est tout-à-fait implicite. Dans un langage procédural non-vectorisé, j’aurais plutôt écrit :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nCette dernière écriture est équivalente mais n’est pas très pratique pour écrire des statistiques….\n\n\n\n\n\n\nNote\n\n\n\nL’opérateur pipe %&gt;% repose sur les axiomes de la programmation fonctionnelle. Il suppose en effet que chaque sortie de fonction ne dépend que des entrées. Il permet de profiter à la fois de la simplicité d’une écriture de type “recette de cuisine” et des avantages de la programmation fonctionnelle.",
    "crumbs": [
      "Paradigmes de programmation"
    ]
  },
  {
    "objectID": "index.html#quizz",
    "href": "index.html#quizz",
    "title": "Introduction : les paradigmes de programmation",
    "section": "Quizz",
    "text": "Quizz\nQuestion 1\n\nDans un langage fonctionnel idéal :\n\n\n\n\n ✗On n’utilise que des procédures (des fonctions sans valeur de retour).\n\n\n ✓On n’utilise que des fonctions dites pures, c’est-à-dire des fonctions purement combinatoires.\n\n\n ✗On n’utilise que des fonctions, pures, ou non.\n\n\n ✗Différentes étapes successives qu’on appelle fonctions. On les applique sur des objets qu’elles modifient progressivement.\n\n\n\n\n\nQuestion 2\n\nQuel est le rapport entretenu entre R et la Programmation Orientée Objet ?\n\n\n\n\n ✗R est un archétype de langage de POO.\n\n\n ✗On ne peut pas du tout faire de POO en R.\n\n\n ✗Objection votre honneur !\n\n\n ✓R est surtout un langage fonctionnel, mais il présente quelques aspects de POO.\n\n\n\n\n\nQuestion 3\n\nUn langage de bas niveau est un langage caractérisé par sa simplicité.\n\n\n\n\n ✓Non, c’est un langage proche du langage machine, donc souvent assez complexe et verbieux.\n\n\n ✗Exactement ! C’est un langage prévu pour être facile d’appréhension, d’où de “bas niveau”.\n\n\n ✗Non, un langage de bas-niveau est un langage est un langage qui est calculé dans la partie basse des microprocesseurs, tandis que les langages de haut niveau sont déterminés par la partie haute.\n\n\n ✗Non, un langage de bas-niveau est un langage stromosogomique de capacitance inférimitésimale.\n\n\n\n\n\nQuestion 4\n\nAnalysons ce pseudo-code :\n\nclasseur_ods = nouveau_classeur_ods()\nonglet = nouvel_onglet(donnee = “En voilà de la donnée”)\nclasseur_ods.ajouter_onglet(onglet)\nclasseur_ods.enregistrer(“/home/tintin/mon_classeur.ods”)\n\nÀ quel paradigme de programmation cela ressemble ?\n\n\n\n\n ✗Langage procédural\n\n\n ✓Langage objet\n\n\n ✗Langage fonctionnel\n\n\n\n\n\nQuestion 5\n\nAnalysons ce pseudo-code :\n\na = [‘b’, ‘o’, ‘n’, ‘j’, ‘o’, ‘u’, ‘r’, ’ ’]\ni = 1\nwhile a[i] != ’ ’ {\n  print(a[i])\n  print(a[i])\n}\n\nÀ quel paradigme de programmation cela ressemble ?\n\n\n\n\n ✓Langage procédural\n\n\n ✗Langage objet\n\n\n ✗Langage fonctionnel\n\n\n\n\n\nQuestion 6\n\nAnalysons ce pseudo-code :\n\nracine_carrée(multiplier_par(entiers de 1 à 10, 3))\n\nÀ quel paradigme de programmation cela ressemble ?\n\n\n\n\n ✗Langage procédural\n\n\n ✗Langage objet\n\n\n ✓Un langage fonctionnel ! Et vectoriel en plus ! C’est presque R !\n\n\n\n\n\nQuestion 7\n\nOn a vu qu’un langage objet permet notamment d’éviter les dépendances à l’implémentation.\nOn préfère écrire :\n\nmur.peindre(palette.get_couleur())\n\nQue :\n\npeindre_mur(mur, palette[3])\n\nQuel intérêt cela présente ?\n\n\n\n\n ✗Aucun, c’est purement esthétique.\n\n\n ✓Cela permet à un collègue d’être libre de modifier le fonctionnement interne de la palette sans faire bugger le programme de peinture.\n\n\n ✗Compter jusqu’à 3 est difficile car un ordinateur repose sur des nombres binaires. On préfère donc enlever le 3.\n\n\n ✗On a vraiment envie que le programme de peinture dépende du programme de la palette. Il faut que les gens travaillent en équipe et donc qu’ils soient chacun au courant de tout ce qu’il se passe dans l’intégralité du projet.\n\n\n\n\n\nQuestion 8\n\nCombien de méthodes différentes de la classe discman ce pseudo-code utilise-t-il ?\n\ndiscman.brancher_ecouteurs(ecouteurs)\ndiscman.inserer_cd(never_mind_the_bollocks_here_s_the_sex_pistols)\ndiscman.ecouter_cd()\ndiscman.retirer_cd()\ndiscman.inserer_cd(peace_sells_but_who_s_buying)\ndiscman.ecouter_cd()\ndiscman.retirer_cd()\n\n\n\n\n\n ✗1\n\n\n ✗2\n\n\n ✗3\n\n\n ✓4\n\n\n ✗5\n\n\n ✗6\n\n\n ✗7",
    "crumbs": [
      "Paradigmes de programmation"
    ]
  },
  {
    "objectID": "programmation_objet.html",
    "href": "programmation_objet.html",
    "title": "paradigmes_programmation",
    "section": "",
    "text": "Please enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Programmation objet"
    ]
  },
  {
    "objectID": "programmation_objet.html#paradigmes-de-programmation",
    "href": "programmation_objet.html#paradigmes-de-programmation",
    "title": "paradigmes_programmation",
    "section": "",
    "text": "Please enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Programmation objet"
    ]
  }
]