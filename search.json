[
  {
    "objectID": "evaluation.html",
    "href": "evaluation.html",
    "title": "Évaluation des fonctions en R",
    "section": "",
    "text": "R repose (comme beaucoup de langages fonctionnels) sur des expressions. Une expression est comme une phrase en français mais en R. Une expression est simplement un ensemble non-évalué de code R syntaxiquement correct, même si ce sens peut être farfelu ou produire une erreur à l’évaluation dans un environnement (voire dans n’importe quel environnement).\n\n1 + 2\nfunction(x) sin(2*x)\nround(exp(3) + 1, 5)\narnaud &lt;- (bonjour + \"voiture\") ^ sqrt(2 + \"train\")\n1 &lt;- 2\n\nTout ce qui est au dessus est une expression avant d’être évalué, possiblement par une erreur. A contrario, les lignes ci-dessous ne peuvent pas correspondre à une expression. Elles sont syntaxiquement incorrectes.\n2 *\nexp(\n&lt;- 3\nPour ne pas évaluer du code R syntaxiquement correct et le laisser sous forme d’expression, on peut utiliser quote().\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLe code syntaxiquement incorrect ne peut lui pas former une expression :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Évaluation des fonctions en R"
    ]
  },
  {
    "objectID": "evaluation.html#expression",
    "href": "evaluation.html#expression",
    "title": "Évaluation des fonctions en R",
    "section": "",
    "text": "R repose (comme beaucoup de langages fonctionnels) sur des expressions. Une expression est comme une phrase en français mais en R. Une expression est simplement un ensemble non-évalué de code R syntaxiquement correct, même si ce sens peut être farfelu ou produire une erreur à l’évaluation dans un environnement (voire dans n’importe quel environnement).\n\n1 + 2\nfunction(x) sin(2*x)\nround(exp(3) + 1, 5)\narnaud &lt;- (bonjour + \"voiture\") ^ sqrt(2 + \"train\")\n1 &lt;- 2\n\nTout ce qui est au dessus est une expression avant d’être évalué, possiblement par une erreur. A contrario, les lignes ci-dessous ne peuvent pas correspondre à une expression. Elles sont syntaxiquement incorrectes.\n2 *\nexp(\n&lt;- 3\nPour ne pas évaluer du code R syntaxiquement correct et le laisser sous forme d’expression, on peut utiliser quote().\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLe code syntaxiquement incorrect ne peut lui pas former une expression :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Évaluation des fonctions en R"
    ]
  },
  {
    "objectID": "evaluation.html#évaluation-paresseuse-et-court-circuit",
    "href": "evaluation.html#évaluation-paresseuse-et-court-circuit",
    "title": "Évaluation des fonctions en R",
    "section": "Évaluation paresseuse et court-circuit",
    "text": "Évaluation paresseuse et court-circuit\nR est fainéant. Il n’évaluera les arguments d’une fonction qu’au dernier moment s’il en a besoin (évaluation paresseuse des arguments). Les expressions employant des contrôle (if, else…) définissent elles aussi une forme de paresse dans la mesure où leurs sous-parties non-retenues ne sont pas évaluées (évaluation paresseuse des structures de contrôle). À l’intérieur même des expressions, les expressions faites d’opérateurs logiques unitaires (&& et || mais pas & ni | qui sont vectoriels) évaluent elles aussi le moins possible de leurs sous-parties (court-circuit).\n\n\n\n\n\n\nRemarque\n\n\n\nDans le monde de R, quand on parle d’évaluation paresseuse, on se réfère surtout à l’évaluation paresseuse des arguments. Mais l’évaluation paresseuse est un concept assez général. L’idée de base est de n’évaluer que ce dont on a absolument besoin.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDans l’exemple précédent, si les arguments n’étaient pas évalués de manière paresseuse, autant l’évaluation de x que celle de y précipiterait une erreur :\n\ncelle de x car stop() est la fonction de R permettant de stopper l’exécution et de retourner une erreur avec le message fourni.\ncelle de y car une matrice avec un nombre de lignes négatifs, ça n’existe pas.\n\nMais le corps de la fonction lazy_eval étant réduit à son plus simple appareil, à savoir simplement TRUE, il ne requiert pas d’en évaluer les arguments. Il n’y a donc aucune erreur d’exécution et la fonction retourne bien TRUE !\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDans l’exemple ci-dessus, on illustre le bon fonctionnement paresseux d’une structure de contrôle. La partie else n’est évaluée que si choix est FALSE.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nL’exemple ci-dessus repose à la fois sur la paresse des structures de contrôle et sur celle des arguments. L’argument x n’est évalué que dans le cas où choix vaut FALSE.\n\n\n\n\n\n\nWarning\n\n\n\n\nlazy_eval_1 &lt;-\n  function(x = stop(\"C'est une erreur !\"),\n           y = matrix(1:9, nrow = -3L)) {\n    truc &lt;- x\n    TRUE\n  }\nlazy_eval_2 &lt;-\n  function(x = stop(\"C'est une erreur !\"),\n           y = matrix(1:9, nrow = -3L)) {\n    x\n    TRUE\n  }\n# Essayer lazy_eval_1() et lazy_eval_2()\n\nL’assignation, de même que simplement écrire une ligne avec pour seul code le nom d’un des arguments, force son évaluation. C’est pourquoi les deux exécutions de fonctions ci-dessus précipitent une erreur\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nOn voit ci-dessus que :\n\nDans le cas de cas de court_circuit_1, le stop() n’est pas évalué si choix vaut FALSE. En effet, peu importe la valeur du deuxième terme, on peut bien deviner que si le premier est faux, la valeur du && doit être FALSE. Pas besoin donc de continuer.\nDans le cas de cas de court_circuit_2, le stop() n’est pas évalué si choix vaut TRUE. En effet, peu importe la valeur du deuxième terme, on peut bien deviner que si le premier est vrai, la valeur du || doit être TRUE. Pas besoin donc de continuer.\n\n\n\n\n\n\n\nWarning\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nAttention, les opérateurs logiques & et |, qui sont normalement prévus pour de la logique vectorielle, ne sont pas court-circuités comme on peut le voir dans l’exemple précédent.",
    "crumbs": [
      "Évaluation des fonctions en R"
    ]
  },
  {
    "objectID": "evaluation.html#évaluation-standard",
    "href": "evaluation.html#évaluation-standard",
    "title": "Évaluation des fonctions en R",
    "section": "Évaluation standard",
    "text": "Évaluation standard\nOn a vu dans le classeur précédent que les appels de fonctions définissent de nouveaux environnements, et que les différents noms d’objets utilisés sont évalués en remontant l’arbre des environnements jusqu’à trouver le bon nom.\nOn a vient également de voir que les expressions sont évaluées au dernier moment, ce que l’on appelle l’évaluation paresseuse. Les expressions sont évaluées dans leur environnement, par exemple celui de leur fonction.\nLa somme de ces deux propriétés définit l’évaluation standard en R.\nR permet cependant des bâtir des exceptions à cette “évaluation standard”. On appelle ces évaluations irrégulières des… Évaluations non-standard (Non-Standard Evaluation, NSE).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLorsque l’on charge un package, par exemple disaggR, on utilise library() avec à l’intérieur un nom qui n’existe pourtant pas dans l’environnement global. Ici l’environnement global ne contient pas d’objet disaggR. C’est une forme d’évaluation non-standard puisque library ne réagit pas comme toutes les fonctions de R. Mais bon, ce n’est pas une évaluation non-standard des plus utiles en soi.\nLa plus utilisée de ces NSE est la tidyeval régnant dans le tidyverse.",
    "crumbs": [
      "Évaluation des fonctions en R"
    ]
  },
  {
    "objectID": "evaluation.html#tidyeval-les-bases",
    "href": "evaluation.html#tidyeval-les-bases",
    "title": "Évaluation des fonctions en R",
    "section": "tidyeval : les bases",
    "text": "tidyeval : les bases\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLorsque l’on exécute le code précédent, on peut se rendre compte que celui-ci n’est pas exécuté par évaluation standard : en effet, le nom height comme le nom name n’existent pas dans l’environnement global. Ils ne remontent pas les environnements. Ils sont évalués dans le contexte du premier argument, en l’occurence dplyr::starwars pour ce qui est de l’appel à filter(), puis filter(dplyr::starwars, height &gt; 200) en ce qui concerne l’appel à select().\ndplyr évite une syntaxe verbieuse et peu lisible. Pour écrire quelque chose de rigoureusement équivalent dans base, on aurait dû écrire le code ci-dessous (on a rajouté ! is.na() car filter() enlève les NA par défaut, et drop = FALSE car sinon R convertit les data.frame d’une seule unique colonne en vecteur).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLa tidyeval aide à cette syntaxe plus légère. En effet, dans dplyr, on n’a pas à répéter systématiquement qu’on se trouve dans le tibble starwars. C’est implicite ! Les arguments de filter() et select() sont tous deux évalués dans le contexte de starwars.",
    "crumbs": [
      "Évaluation des fonctions en R"
    ]
  },
  {
    "objectID": "evaluation.html#tidyeval-comportement-des-expressions-et-des-quosures",
    "href": "evaluation.html#tidyeval-comportement-des-expressions-et-des-quosures",
    "title": "Évaluation des fonctions en R",
    "section": "tidyeval : comportement des expressions et des quosures",
    "text": "tidyeval : comportement des expressions et des quosures\nLorsque l’on donne pour argument height &gt; 200 à dplyr, cela ressemble à ce que l’on a vu plus haut, une expression. En réalité, le tidyverse utilise des quosures, une notion similaire aux expressions mais au comportement différent.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nOn voit ici que l’évaluation de x * height n’est pas interprétée de la même manière selon que l’on définisse une quosure ou une expression. On note deux choses :\n\nheight est évalué de la même manière dans les deux cas. Elles cherchent tout d’abord dans la donnée qui leur est spécifiée, à savoir dplyr::starwars. Dans la mesure où le nom height existe dans ces données, aucune n’a besoin d’aller voir ailleurs.\nPar contre, l’évaluation de x est différente. Dans le cas de l’expression, puisque le nom n’existe pas dans dplyr::starwars, l’évaluation standard va dérouler les environnements à partir de l’environnement d’appel du eval. Ici on trouve directement une valeur, le 1. Et hop ! À contrario, la quosure va dérouler les environnements à partir de l’environnement de création de la quosure. C’est pour cela que x vaut 2.\n\n\n\n\n\n\n\nImportant : Ce n’est pas une distinction futile !\n\n\n\nCela peut sembler futile, mais cette particularité rend l’utilisation de quosure beaucoup plus sécurisée et moins surprenante à l’utilisateur. L’utilisateur n’est pas censé connaitre le code interne des fonctions qu’il utilise (filter, etc.). Si celles-ci évaluaient bêtement les expressions, imaginons que leur code interne contienne une variable x, et que l’utilisateur évalue une expression avec un x, il y aurait conflit quand bien même celui-ci aurait défini un x dans l’environnement global. Ce n’est vraisemblablement pas ce que l’utilisateur attend.",
    "crumbs": [
      "Évaluation des fonctions en R"
    ]
  },
  {
    "objectID": "evaluation.html#tidyeval-sous-le-chapeau-des-quosures",
    "href": "evaluation.html#tidyeval-sous-le-chapeau-des-quosures",
    "title": "Évaluation des fonctions en R",
    "section": "tidyeval : sous le chapeau des quosures",
    "text": "tidyeval : sous le chapeau des quosures\nLorsque l’on définit une quosure, on ne définit en fait rien de plus qu’un couple entre une expression et l’environnement d’appel.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nSi j’affiche en effet le contenu de ma_quosure, je vois que celle-ci contient deux éléments :\n\nL’expression x * height\nUn lien vers l’environnement global\n\nC’est cet environnement global qui permet, lors de la tidyeval, de remonter au bon environnement.\nUn comportement tout-à-fait équivalent à celui des quosures est possible avec des expressions, mais il faut alors spécifier une expression et un environnement.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nOn a rajouté ci-dessus à eval() un argument enclos qui spécifie le lieu où les noms qui ne sont pas trouvés dans les données de envir vont être évaluées. Grâce à cela, l’évaluation de x se fait par rapport à la variable de l’environnement global dans les deux cas !\nLa quosure n’est autre qu’une expression complétée par un environnement de closure, d’où son nom.",
    "crumbs": [
      "Évaluation des fonctions en R"
    ]
  },
  {
    "objectID": "evaluation.html#tidyeval-évaluation-avec-le-bang",
    "href": "evaluation.html#tidyeval-évaluation-avec-le-bang",
    "title": "Évaluation des fonctions en R",
    "section": "tidyeval : évaluation avec le bang (!!) !",
    "text": "tidyeval : évaluation avec le bang (!!) !\nOn a donc vu les :\n\nnoms (également appelés symboles), les mots désignant des objets à évaluer dans des environnements.\nquosures, un couple entre expression et environnement d’appel.\n\nL’usage des deux en même temps est une caractéristique particulière de la programmation dans le tidyverse, particulièrement dans dplyr.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDans l’exemple ci-dessus, on a programmé avec dplyr ! On a fait une fonction à qui on peut suggérer un filtre et un nom de colonne, et ces éléments vont être évalués dans le contexte des données de tbl.\nComment est-ce que cela fonctionne ? L’idée de base est que enquo() et ensym() empêchent l’évaluation (sous la forme d’une quosure et d’un symbole, respectivement), tandis que les bang !! vont au contraire demander évalue-moi cela ici.\nPlus spécifiquement, avec le couple arg &lt;- enquo(arg) / !!, on va :\n\nÉviter l’évaluation d’un argument et le transformer en objet de type quosure s’il n’est pas déjà une quosure, en enfermant l’environnement parent.\nS’il est déjà une quosure, il va passer la quosure telle quelle, en conservant l’environnement déjà enfermé dedans.\n\nDe cette manière, d’appel de fonction en appel de fonction, on transmet l’environnement dans lequel la quosure a été effectivement saisie (ici height &gt; x) .\nIci, il n’y a qu’un unique appel de fonction. L’environnement contenu dans la quosure transmise à filter n’est autre que l’environnement global dans lequel le x peut s’évaluer.\nL’effet du couple arg &lt;- ensym(arg) / !! est plus simple puisque les symboles n’enferment pas de lien à un environnement :\n\nOn évite l’évaluation du symbole avec ensym()\nOn dit de l’évaluer avec !! dans une nouvelle fonction (qui à son tour peut en fait stopper l’évaluation avec un nouveau ensym() et la passer à nouveau plus bas avec !!)\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nOn voit ci-dessus que l’on peut même utiliser les bang !! avant le = dans une fonction qui utilise des = comme summarise. Mais il faut alors modifier le = par un := pour que ça marche.\n\n\n\n\n\n\nTip\n\n\n\nIl existe un raccourci pour enquo() et !! qui allège un peu, mais est sans doute un peu moins clair et ne permet pas de faire une distinction entre symboles et quosures. On aurait pu écrire :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nCela à l’avantage d’être plus succinct ; cela a le désavantage d’être moins explicite. C’est au choix.",
    "crumbs": [
      "Évaluation des fonctions en R"
    ]
  },
  {
    "objectID": "evaluation.html#tidyeval-dots-et-bang-bang",
    "href": "evaluation.html#tidyeval-dots-et-bang-bang",
    "title": "Évaluation des fonctions en R",
    "section": "tidyeval : dots et bang bang (!!!) !",
    "text": "tidyeval : dots et bang bang (!!!) !\nParfois, on a besoin non pas d’un seul argument symbole/quosure mais d’un nombre indéfini. Des variantes de enquo() et ensym() existent au pluriel. Ces variantes sont enquos() et ensyms() et s’utilisent avec l’opérateur !!!.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nTout d’abord, l’exemple ci-dessus reprend le filtre_et_select mais en acceptant plusieurs sélections dans les dots, car on a utilisé ensyms(). On a donc de manière conjointe utilisé !!!.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nInversement, dans ce dernier exemple, on a laissé la possibilité de spécifier plusieurs filtres en utilisant enquos() et en les faisant évaluer par !!! dans le filter().\n\n\n\n\n\n\nTip\n\n\n\nLes !!! passent aussi les noms d’arguments dans les ..., donc sont aussi solubles avec les fonctions de type rename ou summarise.",
    "crumbs": [
      "Évaluation des fonctions en R"
    ]
  },
  {
    "objectID": "evaluation.html#exercices",
    "href": "evaluation.html#exercices",
    "title": "Évaluation des fonctions en R",
    "section": "Exercices",
    "text": "Exercices\n\nExercice 1\nÉcrire une fonction filtre_et_summarise de la forme function(tbl, filtre, ...) et qui :\n\napplique le filtre fourni sur le tibble.\npuis passe à summarise les éléments du ....\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nExercice 2\nOn souhaite écrire une fonction faire_taux(tbl, ...) qui prend dans les ... des conditions booléennes et retourne des taux avec les mêmes noms que ceux des arguments fournis.\nPar exemple, dans :\n\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\n\n\ntbl %&gt;%\n  faire_taux(hello = moyen == \"voiture\" & prenom == \"arnaud\",\n             super = bonjour & moyen == \"voiture\",\n             bonjour = bonjour)\n\ndoit retourner :\n\n\n# A tibble: 1 × 3\n  hello super bonjour\n  &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;\n1   0.5     0    0.25\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nAide 1 (optionnel)\n\n\n\n\n\nOn pourra s’aider d’une première étape de pipe avec transmute. transmute ressemble à mutate mais abandonne toutes les colonnes non-transformées.\n\n\n\n\n\n\n\n\n\nAide 2 (optionnel mais à ne pas consulter avant minimum 15 minutes de brainstorming !)\n\n\n\n\n\nPenser à across() qui permet d’appliquer, dans un mutate(), un transmute() ou un summarise(), une fonction à plusieurs colonnes en même temps.\n\n\n\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nExercice 3\nDans la partie précédente, on a vu comment on peut faire un compteur avec des closures.\n\nnouveau_compteur &lt;-\n  function() {\n    n &lt;- 0L\n    function() {\n      n &lt;&lt;- n + 1L\n      return(n)\n    }\n  }\ncompteur &lt;- nouveau_compteur()\nprint(compteur())\n\n[1] 1\n\nprint(compteur())\n\n[1] 2\n\nprint(compteur())\n\n[1] 3",
    "crumbs": [
      "Évaluation des fonctions en R"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction : les paradigmes de programmation",
    "section": "",
    "text": "Un paradigme de programmation peut être vu comme la philosophie d’un langage. Il prédétermine une manière d’écrire propre à celui-ci, influence ses possibilités, définit une idiomatique conventionnelle (c’est-à-dire, par exemple, une manière d’éviter de copier-coller 500 fois le même paragraphe). Ces paradigmes sont des archétypes ; en réalité, les langages modernes permettent souvent plusieurs paradigmes. Ceux-ci ne correspondent donc pas à une sorte de réglement implacable mais énoncent plutôt différentes manières de structurer du code. Ce qui importe, au fond, c’est d’être suffisamment avisé pour pouvoir faire des choix.\nTrois principaux paradigmes dominent le monde actuel de la programmation. La programmation procédurale, la programmation objet, et la programmation fonctionnelle (cette dernière est le paradigme principal de R).",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#paradigmes-de-programmation",
    "href": "index.html#paradigmes-de-programmation",
    "title": "Introduction : les paradigmes de programmation",
    "section": "",
    "text": "Un paradigme de programmation peut être vu comme la philosophie d’un langage. Il prédétermine une manière d’écrire propre à celui-ci, influence ses possibilités, définit une idiomatique conventionnelle (c’est-à-dire, par exemple, une manière d’éviter de copier-coller 500 fois le même paragraphe). Ces paradigmes sont des archétypes ; en réalité, les langages modernes permettent souvent plusieurs paradigmes. Ceux-ci ne correspondent donc pas à une sorte de réglement implacable mais énoncent plutôt différentes manières de structurer du code. Ce qui importe, au fond, c’est d’être suffisamment avisé pour pouvoir faire des choix.\nTrois principaux paradigmes dominent le monde actuel de la programmation. La programmation procédurale, la programmation objet, et la programmation fonctionnelle (cette dernière est le paradigme principal de R).",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#la-programmation-procédurale",
    "href": "index.html#la-programmation-procédurale",
    "title": "Introduction : les paradigmes de programmation",
    "section": "La programmation procédurale",
    "text": "La programmation procédurale\nLa programmation procédurale est le plus ancien paradigme de programmation. Il s’agit d’une séquence de procédures, c’est-à-dire une série d’étapes à réaliser pour faire quelque chose. On peut voir cela comme une recette de cuisine.\nSupposons que l’on veuille peindre un mur en vert, on pourrait faire :\n\nmettre_sur_palette(palette, bleu)\nmettre_sur_palette(palette, jaune)\nmélanger_couleurs_sur_palette(palette)\npeindre_mur(mur, palette[3])\n\nIl faut bien noter ce qui se passe à la fin de la dernière ligne : on a sélectionné la couleur de la palette en appelant son emplacement numéro 3 avec palette[3]. Cela suppose d’une part que l’on connait le fonctionnement interne des palettes, et d’autre part que cette structure interne ne change jamais. Si l’on change le code interne de la palette, il faudra aussi changer notre code. Notre programme dépend de l’implémentation de la palette.\nToutefois, la programmation purement procédurale n’est pas sans intérêt dans les langages proches du matériel (on les appelle “de bas niveau”). Elle est par exemple utilisée dans le langage C. Le véritable langage des machines est en effet en lui-même procédural ; un processeur est essentiellement un composant électronique qui manipule des états de manière séquentielle. La programmation procédurale pour autant pas restreinte aux langages de bas-niveau ; Python notamment est un peu fourre-tout, mais reste relativement procédural.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#la-programmation-orientée-objet-poo",
    "href": "index.html#la-programmation-orientée-objet-poo",
    "title": "Introduction : les paradigmes de programmation",
    "section": "La programmation orientée objet (POO)",
    "text": "La programmation orientée objet (POO)\nLa programmation orientée objet a émergé du besoin de faire apparaître une syntaxe disciplinée et plus proche d’une perception humaine. Pour ce faire, on s’inspire du monde réel : il n’y a pas besoin de connaitre le fonctionnement électronique d’une télécommande pour appuyer sur ses boutons. Il est pas attendu non plus que l’utilisateur d’une télévision aille bidouiller ses circuits imprimés pour s’en servir. Dans un langage objet, l’exemple précédent pourrait s’écrire :\n\npalette.ajouter(bleu)\npalette.ajouter(jaune)\npalette.mélanger()\nmur.peindre(palette.get_couleur())\n\nOn voit que palette, une instance de palette, possède a minima trois méthodes (ajouter, mélanger, et get_couleur). Puisqu’on s’est astreints à ne jamais accéder aux états internes de la palette, on a découplé le programme de peinture de celui des palettes. On n’a plus besoin de savoir comment est structurée intérieurement une palette (on ne sélectionne plus son 3ème élément). La différence est de taille : la personne qui s’occupe de la maintenance des palettes peut maintenant les changer comme elle veut sans risquer de causer une erreur dans le programme de peinture (par exemple un mur jaune fluo à poids mauves). La seule chose qui doit être respectée, c’est le comportement des différentes méthodes.\n\n\n\n\n\n\nNote\n\n\n\nJava et C++ sont des langages objet populaires.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#la-programmation-fonctionnelle",
    "href": "index.html#la-programmation-fonctionnelle",
    "title": "Introduction : les paradigmes de programmation",
    "section": "La programmation fonctionnelle",
    "text": "La programmation fonctionnelle\nLà où la POO s’inspire des objets dans le monde réel, la programmation fonctionnelle s’inspire du monde des mathématiques. L’idée fondamentale de la programmation fonctionnelle est de ne plus manipuler d’états ; on n’utilise que ce qu’on appelle des “fonctions pures”. Celles-ci se comportent comme une calculatrice sans mémoire. Elles font un calcul purement combinatoire ; elles sont prévues pour retourner toujours le même résultat à partir des mêmes entrées.\n\nmur = mur_peint(couleur = mélanger(jaune, bleu))\n\nLa syntaxe fonctionnelle étant proche d’une écriture mathématique, elle convient aux langages de haut niveau prévus pour le calcul scientifique, comme R. Pendant longtemps (jusqu’aux années 2010), ce paradigme a été considéré comme assez académique et réservé aux profs de facs. Depuis les années 2010, cependant, le paradigme fonctionnel a rencontré un très net regain de popularité et est sorti des universités. Ses principaux intérêts sont :\n\nla grande facilité de déboggage et de test (une entrée doit toujours retourner la même sortie)\nla beauté/maintenabilité du code\nla forte parallélisabilité des calculs : les résultats ne dépendant que de leurs entrées, il est potentiellement possible de calculer plusieurs choses en même temps si l’on dispose de plusieurs CPU. C’est notamment cet aspect qui permet par exemple au package arrow d’être extrêmement rapide ; les calculs sont faits de manière possiblement concourrante plutôt que consécutive.\n\n\n\n\n\n\n\nNote\n\n\n\nOutre R, Haskell, Scala et Lisp sont des langages fonctionnels.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#r-un-langage-fonctionnel-vectoriel-avec-quelques-éléments-de-poo",
    "href": "index.html#r-un-langage-fonctionnel-vectoriel-avec-quelques-éléments-de-poo",
    "title": "Introduction : les paradigmes de programmation",
    "section": "R : un langage fonctionnel, vectoriel, avec quelques éléments de POO",
    "text": "R : un langage fonctionnel, vectoriel, avec quelques éléments de POO\nR est très majoritairement un langage fonctionnel. Dans la mesure où aucun langage n’est entièrement soluble dans un paradigme, il présente également quelques petits traits de programmation objet tordus pour correspondre au coeur d’un langage fonctionnel. Le principal système de programmation objet en R, S3 (qui n’a rien à voir avec le protocole de stockage même s’il s’appelle pareil), adapte les principes de la POO dans le contexte de la programmation fonctionnelle. Grosso modo, dans R, on définit des classes d’objets de manière beaucoup moins formelle que dans la POO (par exemple des tibble, des ggplot…), et on applique des fonctions pures dessus. Contrairement à ce qu’il se passe dans un langage POO, les objets de R sont immutables.\nD’accord, mais qu’est-ce que l’immutabilité ?\nDans presque tous les langages de programmation objet, si on fait :\n\nmur_a = nouveau_mur()\nmur_a.peindre(rouge)\nmur_b = mur_a\nmur_b.peindre(vert)\nmur_a.get_couleur() –&gt; renvoie vert\nmur_b.get_couleur() –&gt; renvoie vert\n\nLa couleur de mur_a a aussi changé ! En fait, dans un langage de POO, on crée des instances avec un constructeur (ici nouveau_mur). mur_a et mur_b correspondent au même mur. Si on modifie l’un, on modifie l’autre.\nA contrario, dans R, on aura plutôt :\n\nmur_a = nouveau_mur()\nmur_a.peindre(rouge)\nmur_b = mur_a\nmur_b.peindre(vert)\nmur_a.get_couleur() –&gt; renvoie rouge\nmur_b.get_couleur() –&gt; renvoie vert\n\nDans R, en fait, tout se passe comme si on ne manipulait que des valeurs, même quand on manipule des objets. On ne crée pas vraiment d’instances de murs.\nUn autre aspect particulier de R est qu’il est vectoriel. Si je fais :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLa vectorisation est tout-à-fait implicite. Dans un langage procédural non-vectorisé, j’aurais plutôt écrit :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nCette dernière écriture est équivalente mais n’est pas très pratique pour écrire des statistiques….\n\n\n\n\n\n\nNote\n\n\n\nL’opérateur pipe %&gt;% repose sur les axiomes de la programmation fonctionnelle. Il suppose en effet que chaque sortie de fonction ne dépend que des entrées. Il permet de profiter à la fois de la simplicité d’une écriture de type “recette de cuisine” et des avantages de la programmation fonctionnelle.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#quizz",
    "href": "index.html#quizz",
    "title": "Introduction : les paradigmes de programmation",
    "section": "Quizz",
    "text": "Quizz\n\nQuestion 1\n\nDans un langage fonctionnel idéal :\n\n\n\n\n ✗On n’utilise que des procédures (des fonctions sans valeur de retour).\n\n\n ✓On n’utilise que des fonctions dites pures, c’est-à-dire des fonctions purement combinatoires.\n\n\n ✗On n’utilise que des fonctions, pures, ou non.\n\n\n ✗Différentes étapes successives qu’on appelle fonctions. On les applique sur des objets qu’elles modifient progressivement.\n\n\nEffacer la réponse\n\n\n\n\n\n\n\n\n\n\nQuestion 2\n\nQuel est le rapport entretenu entre R et la Programmation Orientée Objet ?\n\n\n\n\n ✗R est un archétype de langage de POO.\n\n\n ✗On ne peut pas du tout faire de POO en R.\n\n\n ✗Objection votre honneur !\n\n\n ✓R est surtout un langage fonctionnel, mais il présente quelques aspects de POO.\n\n\nEffacer la réponse\n\n\n\n\n\n\n\n\n\n\nQuestion 3\n\nUn langage de bas niveau est un langage caractérisé par sa simplicité.\n\n\n\n\n ✓Non, c’est un langage proche du langage machine, donc souvent assez complexe et verbieux.\n\n\n ✗Exactement ! C’est un langage prévu pour être facile d’appréhension, d’où de “bas niveau”.\n\n\n ✗Non, un langage de bas-niveau est un langage est un langage qui est calculé dans la partie basse des microprocesseurs, tandis que les langages de haut niveau sont déterminés par la partie haute.\n\n\n ✗Non, un langage de bas-niveau est un langage stromosogomique de capacitance inférimitésimale.\n\n\nEffacer la réponse\n\n\n\n\n\n\n\n\n\n\nQuestion 4\n\nAnalysons ce pseudo-code :\n\nclasseur_ods = nouveau_classeur_ods()\nonglet = nouvel_onglet(donnee = “En voilà de la donnée”)\nclasseur_ods.ajouter_onglet(onglet)\nclasseur_ods.enregistrer(“/home/tintin/mon_classeur.ods”)\n\nÀ quel paradigme de programmation cela ressemble ?\n\n\n\n\n ✗Langage procédural\n\n\n ✓Langage objet\n\n\n ✗Langage fonctionnel\n\n\nEffacer la réponse\n\n\n\n\n\n\n\n\n\n\nQuestion 5\n\nAnalysons ce pseudo-code :\n\na = [‘b’, ‘o’, ‘n’, ‘j’, ‘o’, ‘u’, ‘r’, ’ ’]\ni = 1\nwhile a[i] != ’ ’ {\n  print(a[i])\n  print(a[i])\n}\n\nÀ quel paradigme de programmation cela ressemble ?\n\n\n\n\n ✓Langage procédural\n\n\n ✗Langage objet\n\n\n ✗Langage fonctionnel\n\n\nEffacer la réponse\n\n\n\n\n\n\n\n\n\n\nQuestion 6\n\nAnalysons ce pseudo-code :\n\nracine_carrée(multiplier_par(entiers de 1 à 10, 3))\n\nÀ quel paradigme de programmation cela ressemble ?\n\n\n\n\n ✗Langage procédural\n\n\n ✗Langage objet\n\n\n ✓Un langage fonctionnel ! Et vectoriel en plus ! C’est presque R !\n\n\nEffacer la réponse\n\n\n\n\n\n\n\n\n\n\nQuestion 7\n\nOn a vu qu’un langage objet permet notamment d’éviter les dépendances à l’implémentation.\nOn préfère écrire :\n\nmur.peindre(palette.get_couleur())\n\nQue :\n\npeindre_mur(mur, palette[3])\n\nQuel intérêt cela présente ?\n\n\n\n\n ✗Aucun, c’est purement esthétique.\n\n\n ✓Cela permet à un collègue d’être libre de modifier le fonctionnement interne de la palette sans faire bugger le programme de peinture.\n\n\n ✗Compter jusqu’à 3 est difficile car un ordinateur repose sur des nombres binaires. On préfère donc enlever le 3.\n\n\n ✗On a vraiment envie que le programme de peinture dépende du programme de la palette. Il faut que les gens travaillent en équipe et donc qu’ils soient chacun au courant de tout ce qu’il se passe dans l’intégralité du projet.\n\n\nEffacer la réponse\n\n\n\n\n\n\n\n\n\n\nQuestion 8\n\nCombien de méthodes différentes de la classe discman ce pseudo-code utilise-t-il ?\n\ndiscman.brancher_ecouteurs(ecouteurs)\ndiscman.inserer_cd(never_mind_the_bollocks_here_s_the_sex_pistols)\ndiscman.ecouter_cd()\ndiscman.retirer_cd()\ndiscman.inserer_cd(peace_sells_but_who_s_buying)\ndiscman.ecouter_cd()\ndiscman.retirer_cd()\n\n\n\n\n\n ✗1\n\n\n ✗2\n\n\n ✗3\n\n\n ✓4\n\n\n ✗5\n\n\n ✗6\n\n\n ✗7\n\n\nEffacer la réponse",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_1.html",
    "href": "fonctions_ordre_superieur_1.html",
    "title": "Fonctions d’ordre supérieur 1 (arguments)",
    "section": "",
    "text": "En informatique, la notion de fonction d’ordre supérieur désigne une fonction avec au moins l’une des propriétés suivantes :\n\nElle a pour argument une ou des fonctions\nElles retournent a minima une fonction\n\nLes fonctions d’ordre supérieur sont un élément central permettant l’expressivité des langages fonctionnels.\nDans cette première partie sur les fonctions d’ordre supérieur, nous abordons la thématique des fonctions avec ayant des arguments fonctionnels.",
    "crumbs": [
      "Fonctions d'ordre supérieur 1 (arguments)"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_1.html#fonctions-dordre-supérieur",
    "href": "fonctions_ordre_superieur_1.html#fonctions-dordre-supérieur",
    "title": "Fonctions d’ordre supérieur 1 (arguments)",
    "section": "",
    "text": "En informatique, la notion de fonction d’ordre supérieur désigne une fonction avec au moins l’une des propriétés suivantes :\n\nElle a pour argument une ou des fonctions\nElles retournent a minima une fonction\n\nLes fonctions d’ordre supérieur sont un élément central permettant l’expressivité des langages fonctionnels.\nDans cette première partie sur les fonctions d’ordre supérieur, nous abordons la thématique des fonctions avec ayant des arguments fonctionnels.",
    "crumbs": [
      "Fonctions d'ordre supérieur 1 (arguments)"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_1.html#manipuler-des-fonctions-avec-des-fonctions",
    "href": "fonctions_ordre_superieur_1.html#manipuler-des-fonctions-avec-des-fonctions",
    "title": "Fonctions d’ordre supérieur 1 (arguments)",
    "section": "Manipuler des fonctions avec des fonctions",
    "text": "Manipuler des fonctions avec des fonctions\nOn a vu dans le point précédent deux fonctions qui s’appliquent sur des fonctions. do.call nous a permis d’appliquer une fonction ... sur une liste, tandis que Reduce nous a permis d’écrire 2 + 3 + 7 + 1 de manière un peu plus jolie qu’à la main.\nOn a vu aussi que R est un langage principalement fonctionnel. En fait, R offre un certain nombre de fonctions permettant d’appliquer des fonctions de différentes manières. Nous verrons ici lapply, vapply, Map, replicate, apply, do.call, Reduce.",
    "crumbs": [
      "Fonctions d'ordre supérieur 1 (arguments)"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_1.html#lapply-appliquer-une-fonction-à-chaque-élément-dune-liste-ou-dun-vecteur",
    "href": "fonctions_ordre_superieur_1.html#lapply-appliquer-une-fonction-à-chaque-élément-dune-liste-ou-dun-vecteur",
    "title": "Fonctions d’ordre supérieur 1 (arguments)",
    "section": "lapply : appliquer une fonction à chaque élément d’une liste ou d’un vecteur",
    "text": "lapply : appliquer une fonction à chaque élément d’une liste ou d’un vecteur\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLa fonction function(x) c(x, x, x) demande à répéter trois fois un élément. Cette fonction est appliquée terme à terme à chaque élement de la liste.\n\nc(\"a\", \"b\") donne c(\"a\", \"b\", \"a\", \"b\", \"a\", \"b\")\nc(\"c\", \"d\", \"e\") donne c(\"c\", \"d\", \"e\", \"c\", \"d\", \"e\", \"c\", \"d\", \"e\")\nc(\"f\", \"g\") donne c(\"f\", \"g\", \"f\", \"g\", \"f\", \"g\")\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLe calcul ci-dessus montre qu’on peut utiliser lapply à l’intérieur d’une autre fonction.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nCe calcul illustre un aspect implicite des deux précédentes syntaxes utilisées : celles-ci utilisent function(x) c(x, x, x) en lieu et place d’un nom de fonction à l’intérieur du lapply ! On appelle cela des fonctions anonymes. Si une fonction n’a pour vocation que d’être utilisée une seule fois, cela peut rendre la syntaxe plus claire et plus élégante qu’une fonction nommée.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDans ce dernier calcul, on remarque que l’on peut appliquer lapply sur un vecteur.\nDans les 4 calculs, on se rend compte que le résultat de lapply est une liste. lapply retourne en effet une liste même dans le cas du quatrième calcul qui lui soumet un vecteur.\n\n\n\n\n\n\nNote\n\n\n\nDans les versions de R récentes, on peut utiliser la notation compacte \\(x) c(x, x, x) à la place de function(x) c(x, x, x) pour désigner une fonction.\nÀ l’intérieur de l’écosystème tidyverse, on peut également utiliser la notation très compacte ~c(.x, .x, .x).",
    "crumbs": [
      "Fonctions d'ordre supérieur 1 (arguments)"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_1.html#map-appliquer-une-fonction-multi-paramètres-termes-à-termes",
    "href": "fonctions_ordre_superieur_1.html#map-appliquer-une-fonction-multi-paramètres-termes-à-termes",
    "title": "Fonctions d’ordre supérieur 1 (arguments)",
    "section": "Map : appliquer une fonction multi-paramètres termes à termes",
    "text": "Map : appliquer une fonction multi-paramètres termes à termes\nOn a vu avec lapply comment appliquer une fonction sur chaque termes d’une liste ou d’un vecteur et retourner une liste. Cependant, parfois, un seul argument ne suffit pas, et l’on a envie d’appliquer une fonction terme à terme sur plusieurs listes ou vecteurs. La fonction Map remplit ce besoin.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nOn voit ici que la fonction Map permet d’appliquer termet à terme la fonction paste sur deux vecteurs.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nL’argument MoreArgs de Map permet de rajouter une liste d’arguments complémentaires, qui restent fixes entre tous les appels.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nOn aurait aussi tout aussi pu utiliser une fonction anonyme pour spécifier des arguments complémentaires. C’est au choix !\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLa fonction Map peut utiliser autant d’arguments que l’on veut, dès lors que la fonction mappée est compatible avec ce nombre d’arguments.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLa fonction Map peut tout-à-fait utiliser des listes. Ici, elle renvoie donc une liste appliquant la fonction + terme à terme :\n\nc(1L, 2L, 3L) + c(10L, 11L, 12L) pour le premier terme.\nc(4L, 5L, 6L, 7L) + c(13L, 14L, 15L, 16L) pour le deuxième terme.\nc(8L, 9L) + c(17L, 18L) pour le troisième terme.",
    "crumbs": [
      "Fonctions d'ordre supérieur 1 (arguments)"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_1.html#replicate-une-variante-commode-de-lapply-pour-les-générations-de-nombres-aléatoires",
    "href": "fonctions_ordre_superieur_1.html#replicate-une-variante-commode-de-lapply-pour-les-générations-de-nombres-aléatoires",
    "title": "Fonctions d’ordre supérieur 1 (arguments)",
    "section": "replicate : une variante commode de lapply pour les générations de nombres aléatoires",
    "text": "replicate : une variante commode de lapply pour les générations de nombres aléatoires\nCertaines fonctions utiles en statistiques génèrent des nombres aléatoires. Par exemple, runif(2L) renvoie 2L nombres entre 0 et 1 selon une loi uniforme. Si on veut générer 4 vecteurs de 2 nombres aléatoires, on voudrait faire un lapply sur function() runif(2L).\nLe problème, c’est que cette fonction est sans paramètre. Du coup comment lui spécifier un lapply ?\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nL’astuce ci-dessus permet de résoudre le problème ; on a répété 4 fois le 2L. On applique ensuite donc function(n) runif(n) sur c(2L, 2L, 2L, 2L). Chaque élément du vecteur renvoie alors un vecteur de deux nombres aléatoires. Ce n’est cependant pas des plus élégants.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nreplicate est une variante de lapply qui permet d’évaluer une expression plusieurs fois de suite. Cela n’est, bien entendu, utile que dans le cas où cette expression renvoie des résultats différents à chaque évaluation, ce qui est notamment le cas en ce qui concerne la générations de nombres aléatoires.\nOn note l’argument simplify = FALSE à la fin. Si celui-ci n’est pas spécifié, il est par défaut défini à la valeur TRUE, et alors replicate se comporte comme un sapply ; il essaye de construire des matrices.",
    "crumbs": [
      "Fonctions d'ordre supérieur 1 (arguments)"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_1.html#apply-appliquer-une-fonction-sur-les-colonnes-ou-les-lignes-dune-matrice",
    "href": "fonctions_ordre_superieur_1.html#apply-appliquer-une-fonction-sur-les-colonnes-ou-les-lignes-dune-matrice",
    "title": "Fonctions d’ordre supérieur 1 (arguments)",
    "section": "apply : appliquer une fonction sur les colonnes ou les lignes d’une matrice",
    "text": "apply : appliquer une fonction sur les colonnes ou les lignes d’une matrice\napply permet d’appliquer une fonction par ligne ou par colonne.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDans le tronçon de code ci-dessus, on a appliqué la fonction max (maximum) respectivement sur chaque ligne et chaque colonne. C’est l’argument MARGIN en deuxième position qui permet de déterminer la direction de cette application de fonction (1 pour les lignes, 2 pour les colonnes).\n\n\n\n\n\n\nNote\n\n\n\nIl est à noter que quelques optimisations de ces fonctions existent. rowSums, colSums, rowMeans, colMeans ont toutes les quatre des noms assez parlants qui permettent d’éviter une écriture un peu trop poussive.",
    "crumbs": [
      "Fonctions d'ordre supérieur 1 (arguments)"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_1.html#do.call-appliquer-une-fonction-multi-paramètres-sur-une-liste-darguments",
    "href": "fonctions_ordre_superieur_1.html#do.call-appliquer-une-fonction-multi-paramètres-sur-une-liste-darguments",
    "title": "Fonctions d’ordre supérieur 1 (arguments)",
    "section": "do.call : appliquer une fonction multi-paramètres sur une liste d’arguments",
    "text": "do.call : appliquer une fonction multi-paramètres sur une liste d’arguments\nLa fonction do.call permet d’utiliser une fonction multi-paramètres, par exemple (mais pas obligatoirement) une fonction dépendant de paramètres en dots ..., sur une liste de valeurs.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIci, on a appliqué la fonction paste en même temps sur chaque élément de la liste fournie en argument. On peut noter, également, que les éléments nommés de la liste (ici sep) sont traduits par des arguments nommés.",
    "crumbs": [
      "Fonctions d'ordre supérieur 1 (arguments)"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_1.html#reduce-réduire-une-liste-ou-un-vecteur-darguments-par-application-successive-dun-opérateur-binaire",
    "href": "fonctions_ordre_superieur_1.html#reduce-réduire-une-liste-ou-un-vecteur-darguments-par-application-successive-dun-opérateur-binaire",
    "title": "Fonctions d’ordre supérieur 1 (arguments)",
    "section": "Reduce : réduire une liste ou un vecteur d’arguments par application successive d’un opérateur binaire",
    "text": "Reduce : réduire une liste ou un vecteur d’arguments par application successive d’un opérateur binaire\nLa fonction Reduce permet d’appliquer consécutivement une opération binaire.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nCet exemple (que l’on a déjà vu dans le chapitre précédent) correspond à ((1 + 2) + 8) + (-7). Chaque étape utilise l’opération binaire +.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nComme on le voit ci-dessus, on peut éventuellement, à l’aide de accumulate = TRUE, conserver les résultats intermédiaires de la réduction. À savoir ici 1, puis 1 + 2, puis 1 + 2 + 8 et enfin 1 + 2 + 8 - 7.\nMais Reduce peut être employé dans des calculs plus complexes.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDans l’exemple précédent, on a appliqué sur une liste de fonctions l’opérateur Reduce au sens de la composition. C’est un joli exemple pour montrer la richesse d’un langage fonctionnel et illustrer l’idée que Reduce n’est pas restreint à des opérations numériques. En général, cependant, on préfèrera éviter d’empiler des fonctions non-évaluées. On préfèrera donc une notation intermédiaire comme employé ci-dessous.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIci, plutôt que d’empiler des fonctions en mémoire, on les applique successivement. applique_fonction reste une opération binaire, mais est une loi de composition externe, dans la mesure où f est une fonction tandis que accumulateur est un résultat numérique. On remarque aussi qu’on a utilisé l’argument init de Reduce qui permet d’initialiser l’accumulateur. En effet si on veut obtenir atan(pi) / 3 + 1 il faut bien renseigner qu’on commence à pi quelque part. L’argument right = TRUE permet de parcourir la liste de droite à gauche plutôt que de gauche à droite.",
    "crumbs": [
      "Fonctions d'ordre supérieur 1 (arguments)"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_1.html#exercices",
    "href": "fonctions_ordre_superieur_1.html#exercices",
    "title": "Fonctions d’ordre supérieur 1 (arguments)",
    "section": "Exercices",
    "text": "Exercices\n\nQuestion 1\nÀ l’aide de la fonction pmax (sans utiliser la fonction max), calculer le maximum de cette liste.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\nliste &lt;- list(1, -7, 8, 0)\ndo.call(pmax, liste)\n\n[1] 8\n\n\n\n\n\n\n\nQuestion 2\nGénérer une liste avec 10 vecteurs de taille 60, chacun répartis selon une loi normale d’espérance 3 et d’écart-type 0.5. Vous pouvez consulter l’aide de la fonction rnorm via ?rnorm.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\nreplicate(10, rnorm(n=60,mean = 3,sd = 0.5), simplify = FALSE)\n\n[[1]]\n [1] 2.979632 3.318433 2.563331 3.558493 3.599390 2.178939 2.342247 2.432612\n [9] 3.383216 3.261887 4.434283 2.912481 3.881976 2.800033 3.130028 2.213079\n[17] 2.202670 2.212409 2.572051 2.755709 3.141933 2.803485 2.088953 2.545000\n[25] 3.585328 2.771270 2.292225 3.029265 2.040692 3.162720 3.268463 3.302242\n[33] 2.444689 1.792387 3.138365 2.058658 2.840684 2.419800 4.204023 2.346997\n[41] 3.570918 2.976797 2.642437 3.636039 3.642695 3.355992 2.596345 3.666885\n[49] 2.938943 3.642007 2.999928 2.285802 3.382641 3.458069 3.371800 2.791006\n[57] 2.734322 3.044278 3.449878 2.768778\n\n[[2]]\n [1] 3.508463 3.250922 3.064583 2.399767 2.922210 3.790895 3.175427 3.024209\n [9] 2.963466 2.728782 2.652050 4.136327 3.030456 3.214749 3.579703 3.523878\n[17] 3.215885 3.553096 3.601958 2.295189 2.569708 2.786410 3.293537 2.909634\n[25] 1.973240 2.750321 3.153397 3.149074 3.084578 3.838469 3.551367 3.109347\n[33] 2.658199 2.590370 3.169962 3.785266 3.804618 3.815629 4.163795 2.886607\n[41] 2.982148 2.639684 3.421003 3.181864 3.403755 2.842733 2.955703 3.127930\n[49] 1.106577 3.119279 2.791580 1.826284 2.876778 2.907643 3.356043 2.506411\n[57] 2.678226 2.395165 3.350555 3.647378\n\n[[3]]\n [1] 3.350530 4.328515 4.301180 3.760155 2.942069 2.799914 3.180324 3.545140\n [9] 3.930180 2.378990 2.917173 3.024228 3.020103 3.545132 3.082894 2.836195\n[17] 2.892582 4.101192 2.596472 2.550342 3.357209 3.034259 2.829298 2.125243\n[25] 2.212400 2.765601 2.165986 3.479663 3.235996 3.213083 3.297212 3.091105\n[33] 2.762350 3.347159 2.118236 2.927489 2.533880 3.045116 2.959841 3.575008\n[41] 2.446867 3.156305 3.648994 3.177040 3.356615 2.281260 3.084051 3.077078\n[49] 3.020074 2.300500 2.867690 2.383280 3.030812 2.558296 2.671815 1.985303\n[57] 2.661057 3.271016 2.823588 2.784665\n\n[[4]]\n [1] 3.513869 3.563145 2.540921 1.857730 4.325218 2.588621 2.993531 3.373414\n [9] 2.990647 2.680340 3.717856 2.562117 2.515547 3.253336 2.251805 2.644929\n[17] 3.303606 3.633211 2.667875 3.202625 3.556887 1.985232 3.430491 2.770747\n[25] 3.331935 3.378359 2.652414 3.419041 2.787311 2.866448 3.399559 3.382311\n[33] 3.574026 3.577641 3.066901 2.679197 2.152338 2.499469 3.536584 2.589330\n[41] 3.012073 3.541973 2.026557 1.656934 2.341050 2.327246 2.959925 2.559446\n[49] 2.387584 2.932083 3.114302 2.844944 3.092310 2.996387 3.330661 2.212005\n[57] 2.798795 2.450563 3.429661 3.562793\n\n[[5]]\n [1] 2.752404 3.325075 2.595703 3.711898 3.026325 3.961922 2.779653 2.438632\n [9] 3.210846 3.578000 2.899175 3.308334 3.311692 3.452001 3.001259 3.315468\n[17] 2.128852 2.656517 3.325027 3.359179 3.152003 2.527875 4.017841 3.832621\n[25] 3.924140 2.736013 3.201001 4.066718 3.116622 2.696295 3.508821 2.041451\n[33] 3.052594 2.914800 3.382378 2.745060 3.888453 3.721465 3.262347 2.837387\n[41] 2.859888 2.177939 3.677696 3.278861 2.880902 3.485181 3.152619 3.178588\n[49] 3.392310 3.362481 3.495661 2.077580 3.576614 3.066748 2.422770 2.730525\n[57] 2.847732 2.976960 3.057463 2.033655\n\n[[6]]\n [1] 3.446876 2.435844 2.840653 2.724806 2.306667 3.098280 2.470302 3.633155\n [9] 2.943529 2.592485 3.270099 3.108463 2.306841 3.766884 2.758346 3.367097\n[17] 3.203703 2.874352 3.579005 2.187343 3.107117 3.113053 4.337942 3.276798\n[25] 3.601603 2.024190 3.355027 3.132295 3.471721 2.734382 3.363331 2.730582\n[33] 3.195320 3.501950 2.324527 3.490955 3.945199 2.070199 3.458257 3.517438\n[41] 2.954426 2.566390 3.318619 3.329867 3.041437 3.769488 2.815098 2.872797\n[49] 2.712266 3.671956 3.021233 3.121316 2.888723 4.109014 3.121851 2.517683\n[57] 3.242030 2.253589 3.060056 3.619875\n\n[[7]]\n [1] 1.946731 3.758060 2.227499 2.193976 2.572831 2.658015 3.302729 3.745043\n [9] 2.806163 3.374726 2.622022 2.998766 2.041970 2.915596 3.152219 3.082302\n[17] 3.021301 2.871630 3.667055 3.685610 2.433537 2.917810 4.041329 4.051166\n[25] 3.530716 2.142418 2.999429 3.631800 3.181915 3.641146 3.115224 2.189164\n[33] 3.266329 2.817082 3.114339 2.914315 2.994092 3.081626 2.669519 2.736803\n[41] 2.587806 2.488068 2.152784 3.447928 2.730780 3.179397 3.188077 3.392194\n[49] 2.876482 2.646490 2.217305 3.284532 2.915170 2.511284 2.302175 2.534392\n[57] 3.377534 2.831288 2.775756 3.213412\n\n[[8]]\n [1] 3.569405 2.468038 2.883832 3.043986 3.776335 3.701958 3.862657 2.772308\n [9] 2.736184 3.945043 2.584156 2.471511 2.635573 3.334574 2.492308 3.046154\n[17] 2.929167 3.510875 2.411941 3.168169 2.841899 2.654573 3.718949 2.535817\n[25] 4.011652 2.512144 3.490659 2.611941 2.733482 3.363284 2.427572 3.392632\n[33] 2.885067 2.797244 2.277089 3.119489 3.413620 3.126871 3.310079 2.609598\n[41] 2.650170 2.143882 2.702210 2.880543 3.212602 3.259619 2.628820 2.159704\n[49] 3.914552 3.504677 2.942095 3.183131 3.778926 3.146299 2.743409 3.636979\n[57] 3.968303 1.884886 3.644811 3.545354\n\n[[9]]\n [1] 2.938238 3.447459 3.015328 2.633268 2.842958 2.626092 3.484104 2.520445\n [9] 3.991662 3.182139 3.731174 3.221967 2.051794 3.197832 3.167633 3.348743\n[17] 3.685642 3.369238 2.630575 3.865239 3.797885 2.480595 2.494079 3.674490\n[25] 2.919825 1.764786 3.190208 3.339262 3.104585 3.416847 3.989469 2.889006\n[33] 3.304119 3.907035 2.438912 2.575858 2.389864 2.635358 2.332191 2.720083\n[41] 3.057275 4.037451 2.213101 2.674254 3.045479 2.830937 3.311012 2.590394\n[49] 2.146337 3.487257 2.834414 3.358451 3.173446 3.384954 3.683130 3.152944\n[57] 3.638676 2.568191 3.141091 2.614667\n\n[[10]]\n [1] 2.877046 2.033712 2.774811 3.025577 2.221984 3.686524 2.337497 2.952281\n [9] 2.243325 2.917008 2.963426 2.833388 3.207121 2.312234 2.623052 2.593991\n[17] 3.267501 2.665765 3.844087 2.982430 3.349763 2.345259 3.997617 3.101166\n[25] 4.406678 2.702503 2.614290 2.443730 3.285373 3.558758 2.723101 3.619288\n[33] 2.495631 3.793944 2.925431 3.367147 2.429185 3.093136 2.690731 2.943814\n[41] 3.392731 2.886489 2.620356 2.635799 2.527131 2.586453 3.029367 2.694388\n[49] 2.655432 3.399120 2.687056 3.101453 3.122631 2.725558 3.130375 2.213855\n[57] 2.671945 3.834779 2.882947 2.643030\n\n\n\n\n\n\n\nQuestion 3\nÀ l’aide de la fonction paste0 (qui est comme la fonction paste mais avec l’argument par défaut sep = \"\"), produire la chaine de caractère \"aabbccddeeffgg (...) xxyyzz\". Les lettres en minuscules sont accessibles via letters.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nPropositions de solution\n\n\n\n\n\n\ndo.call(paste0, Map(paste0, letters, letters))\n\n[1] \"aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz\"\n\n# ou\n\ndo.call(paste0, as.list(rep(letters, each = 2)))\n\n[1] \"aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz\"\n\n# ou plus simplement\n\npaste0(rep(letters, each = 2), collapse = \"\")\n\n[1] \"aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz\"\n\n\n\n\n\n\n\nQuestion 4\nObserver cette matrice des permutations en colonnes de 1L:5L :\n\nvecteur &lt;- 1L:5L\nmatrix(\n  c(tail(vecteur, 5L),\n    tail(vecteur, 4L), head(vecteur, 1L),\n    tail(vecteur, 3L), head(vecteur, 2L),\n    tail(vecteur, 2L), head(vecteur, 3L),\n    tail(vecteur, 1L), head(vecteur, 4L)),\n  nrow = length(vecteur),\n  ncol = length(vecteur))\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    2    3    4    5    1\n[3,]    3    4    5    1    2\n[4,]    4    5    1    2    3\n[5,]    5    1    2    3    4\n\n\nPouvez-vous généraliser cette création de matrice à n’importe quel vecteur d’entiers ? Pour ce faire, construisez une fonction super_matrice dont l’unique paramètre est vecteur.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\nvecteur &lt;- 1L:5L\nsuper_matrice &lt;- function(vecteur) {\n  longueur &lt;- length(vecteur)\n  vapply(0L:(longueur - 1L),\n         \\(n) c(tail(vecteur, longueur - n), head(vecteur, n)),\n         rep(0L,longueur))\n}\nsuper_matrice(vecteur)\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    2    3    4    5    1\n[3,]    3    4    5    1    2\n[4,]    4    5    1    2    3\n[5,]    5    1    2    3    4\n\n\n\n\n\n\n\nQuestion 5\nProposer une version du https://fr.wikipedia.org/wiki/Crible_d%27%C3%89ratosth%C3%A8ne faisant apparaître, pour un entier n donné, un vecteur booléen de taille n donnant la primalité (ou non) de l’entier i.\nPar exemple, crible(10) donne c(FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, FALSE, FALSE). En effet 1 n’est pas premier, 2 est premier, 3 est premier…\nOn pourra utiliser la fonction Reduce.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nAide (optionnel mais à ne pas consulter avant 5 minutes de brainstorming !)\n\n\n\n\n\nEssayer, dans un premier temps, d’obtenir une fonction avec i pour argument et un n fixé à l’avance dans l’environnement global, un vecteur :\n\nde taille n\nvalant FALSE sur les multiples de i à l’exception de i lui-même\nvalant TRUE ailleurs\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\nn &lt;- 10L\nest_multiple &lt;- function(i) 1L:n == i | 1L:n %% i != 0L\nest_multiple(2L)\n\n [1]  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\ncrible &lt;- function(n) {\n  Reduce(`&`,\n       lapply(2L:sqrt(n), \\(i) 1L:n == i | 1L:n %% i != 0L),\n       init = c(FALSE, rep(TRUE, n - 1L)))\n}\ncrible(10L)\n\n [1] FALSE  TRUE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE",
    "crumbs": [
      "Fonctions d'ordre supérieur 1 (arguments)"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_2.html",
    "href": "fonctions_ordre_superieur_2.html",
    "title": "Fonctions d’ordre supérieur (retours)",
    "section": "",
    "text": "Que se passe-t-il par exemple quand j’exécute ce code R ? On y appelle une fonction qui renvoie elle-même une fonction. Il y a plein de choses qui s’appellent x ! Comment cela peut bien se résoudre ?\n\n\n\n\n\n\nNote\n\n\n\nOn l’a vu dans la partie précédente, ces fonctions retournant des fonctions sont un des deux types de fonction d’ordre supérieur.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nOn se rend compte de quatre choses :\n\nAucune des assignations (&lt;-) internes aux fonctions n’a modifié l’environnement global ; print(x) affiche toujours 1L.\nLe arg de la fonction mystère semble avoir été passé\nLe résultat du x retourné par fun_1() est celui défini à l’intérieur de la fonction anonyme, à savoir 3L.\nLe résultat du x retourné par fun_2() est celui défini à l’intérieur de la fonction anonyme, à savoir 4L.\n\nPourquoi donc ?\n\nDans R, les objets sont contenus dans des environnements. Les environnements sont plus ou moins des petites bulles :\n\ndans lesquelles on peut assigner des objets (avec&lt;-) de manière totalement isolée les unes des autres. Ici il faut bien comprendre que tous les objets x existent en même temps dans des environnements différents.\nà l’exception de l’emptyenv, tous les environnements indiquent un environnement parent.\nChaque appel de fonction (et non chaque définition) définit un environnement. Ici on crée donc deux environnements différents pour mystere qu’on appelle des instances.\nlorsque l’on recherche un objet dans un environnement et qu’il n’y existe pas, on va chercher dans l’environnement parent (puis à nouveau l’environnement parent si on ne trouve toujours pas et ainsi de suite). Ici, par exemple, fun_1 n’a pas connaissance de arg. Alors on cherche dans l’environnement au dessus. Surprise ! On y trouve arg et l’on peut donc assigner avec cette valeur. C’est ce qui explique que fun_1() et fun_2() peuvent renvoyer des résultats différents.\n\nDans la suite, on s’attardera surtout sur la partie bleue du graphique ci-dessus. La partie orange a été abordée à titre d’information, mais n’est pas vraiment le sujet ici. De notre point de vue, l’environnement le plus bas est donc le globalenv.",
    "crumbs": [
      "Fonctions d'ordre supérieur 2 (retours)"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_2.html#les-environnements",
    "href": "fonctions_ordre_superieur_2.html#les-environnements",
    "title": "Fonctions d’ordre supérieur (retours)",
    "section": "",
    "text": "Que se passe-t-il par exemple quand j’exécute ce code R ? On y appelle une fonction qui renvoie elle-même une fonction. Il y a plein de choses qui s’appellent x ! Comment cela peut bien se résoudre ?\n\n\n\n\n\n\nNote\n\n\n\nOn l’a vu dans la partie précédente, ces fonctions retournant des fonctions sont un des deux types de fonction d’ordre supérieur.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nOn se rend compte de quatre choses :\n\nAucune des assignations (&lt;-) internes aux fonctions n’a modifié l’environnement global ; print(x) affiche toujours 1L.\nLe arg de la fonction mystère semble avoir été passé\nLe résultat du x retourné par fun_1() est celui défini à l’intérieur de la fonction anonyme, à savoir 3L.\nLe résultat du x retourné par fun_2() est celui défini à l’intérieur de la fonction anonyme, à savoir 4L.\n\nPourquoi donc ?\n\nDans R, les objets sont contenus dans des environnements. Les environnements sont plus ou moins des petites bulles :\n\ndans lesquelles on peut assigner des objets (avec&lt;-) de manière totalement isolée les unes des autres. Ici il faut bien comprendre que tous les objets x existent en même temps dans des environnements différents.\nà l’exception de l’emptyenv, tous les environnements indiquent un environnement parent.\nChaque appel de fonction (et non chaque définition) définit un environnement. Ici on crée donc deux environnements différents pour mystere qu’on appelle des instances.\nlorsque l’on recherche un objet dans un environnement et qu’il n’y existe pas, on va chercher dans l’environnement parent (puis à nouveau l’environnement parent si on ne trouve toujours pas et ainsi de suite). Ici, par exemple, fun_1 n’a pas connaissance de arg. Alors on cherche dans l’environnement au dessus. Surprise ! On y trouve arg et l’on peut donc assigner avec cette valeur. C’est ce qui explique que fun_1() et fun_2() peuvent renvoyer des résultats différents.\n\nDans la suite, on s’attardera surtout sur la partie bleue du graphique ci-dessus. La partie orange a été abordée à titre d’information, mais n’est pas vraiment le sujet ici. De notre point de vue, l’environnement le plus bas est donc le globalenv.",
    "crumbs": [
      "Fonctions d'ordre supérieur 2 (retours)"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_2.html#lassignation-remontante--",
    "href": "fonctions_ordre_superieur_2.html#lassignation-remontante--",
    "title": "Fonctions d’ordre supérieur (retours)",
    "section": "L’assignation remontante (<<-)",
    "text": "L’assignation remontante (&lt;&lt;-)\nOn remplace les deux assignations intra-fonctionnelles par un nouvel opérateur, l’assignation remontante &lt;&lt;-.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nOn observe que le x global est cette fois-ci modifié par l’assignation remontante. En effet, cet opérateur remonte les différents environnements parents jusqu’à trouver un x déjà existant et le modifie.\nIci, à chaque affectation, on remonte donc jusqu’à l’environnement global et on trouve x. On modifie alors celui-ci.\n\nÀ la fin de l’exécution, on a donc le schéma ci-dessus. On n’a pas créé de version locale de x.\n\n\n\n\n\n\nNe pas assigner le global\n\n\n\nAttention cependant, quand bien même l’opérateur &lt;&lt;- peut créer des fonctions manipulant l’environnement global comme on vient de le voir, ce n’est pas une bonne pratique. L’utilisation de &lt;&lt;- doit être fait de manière circonscrite à des cas que l’on va aborder dans la suite de cette page. Modifier l’environnement global est le plus souvent une (très) mauvaise pratique. En effet, cela rompt complètement le paradigme fonctionnel dès lors que l’on a des états globaux pouvant mener à des interdépendances, des problèmes d’isolation…\n\n\n\n\n\n\n\n\nNote\n\n\n\nPar défaut, si la remontée des environnements ne donne rien, l’assignation remontante assignera dans l’environnement global.\n\n\nQue se passe-t-il si on n’utilise l’assignation remontante que dans la fonction anonyme et plus pour le x &lt;- 2L de la fonction de second ordre ? Pourquoi ?\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nRéponse\n\n\n\n\n\n\nx &lt;- 1L\nmystere &lt;-\n  function(arg) {\n    x &lt;- 2L\n    function() {\n      x &lt;&lt;- arg\n      return(x)\n    }\n  }\n\nfun_1 &lt;- mystere(3L)\nfun_2 &lt;- mystere(4L)\nprint(x)\n\n[1] 1\n\nprint(fun_1())\n\n[1] 3\n\nprint(x)\n\n[1] 1\n\nprint(fun_2())\n\n[1] 4\n\nprint(x)\n\n[1] 1\n\n\nEn apparence, les fonctions semblent se comporter à nouveau comme si on utilisait l’assignation locale. Mais, en réalité, le comportement par environnements est différent.\n\nÀ la fin de l’exécution on a le graphe ci-dessus. Les x &lt;- 2L des différentes instances de mystère ont été ecrasés respectivement par les x &lt;&lt;- 3L et x &lt;&lt;- 4L de fun_1 fun_2. Ici, comme on n’utilise de toutes manières pas les valeur 2L, ce n’est pas très grave. On préserve l’isolation entre instances donc tout va bien ; même si ici la notation est inutile.",
    "crumbs": [
      "Fonctions d'ordre supérieur 2 (retours)"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_2.html#closures",
    "href": "fonctions_ordre_superieur_2.html#closures",
    "title": "Fonctions d’ordre supérieur (retours)",
    "section": "Closures",
    "text": "Closures\nOn a vu plus que des fonctions peuvent retourner des fonctions, et qu’il s’agit d’un des deux types de fonctions d’ordre supérieur. Dans R, on appelle aussi ces fonctions des closures (fermetures en français, mais le terme n’est pas très employé).\nCe nom illustre un aspect de ces fonctions d’ordre supérieur, et une utilisation particulière. On a vu qu’il est possible d’écrire dans l’environnement parent tout en préservant l’isolation entre instances. Et bien utilisons cette propriété !\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nMais que se passe-t-il ? C’est très étonnant ! Il semble que l’on ait défini des états ; et pourtant il n’y a aucune variable n dans l’environnement global !\n\nEn fait, on appelle ces fonctions des closures parce qu’elles “enferment” leur environnement parent. Elle permettent de maintenir un espace isolé où l’on peut tout-à-fait faire des modifications.\nCette astuce est puissante et permet de maintenir des états à l’intérieur d’un langage fonctionnel. Cela rompt l’axiome maximaliste d’un langage fonctionnel idéal qui ne contiendrait que des fonctions complètement pures, mais cela rompt cette approche de manière maitrisée, la plus locale possible. On doit bien sûr n’user de cette astuce qu’avec parcimonie, quand cela semble nécessaire.",
    "crumbs": [
      "Fonctions d'ordre supérieur 2 (retours)"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_2.html#closures-complexes",
    "href": "fonctions_ordre_superieur_2.html#closures-complexes",
    "title": "Fonctions d’ordre supérieur (retours)",
    "section": "Closures complexes",
    "text": "Closures complexes\nUne closure peut renvoyer plusieurs fonctions différentes par exemple dans une liste. On s’approche alors beaucoup de la définition d’un objet en Programmation Orientée Objet. En effet, chaque instance de fonctions a des états, et différentes méthodes qui permettent de modifier ces états.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIci, les deux appels de nouvelle_resolution() permettent de définir deux espaces différents. Dans chacun de ces environnements, les fonctions setX(), setY(), getX() et getY() agiront, comme on le voit dans le schéma ci-dessous.",
    "crumbs": [
      "Fonctions d'ordre supérieur 2 (retours)"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_2.html#quizz",
    "href": "fonctions_ordre_superieur_2.html#quizz",
    "title": "Fonctions d’ordre supérieur (retours)",
    "section": "Quizz",
    "text": "Quizz\n\nQuestion 1\n\nC’est lors de la définition de la fonction que l’on détermine son environnement.\n\n\n\n\n ✗Vrai\n\n\n ✓Faux\n\n\nEffacer la réponse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRéponse\n\n\n\n\n\nC’est lors de l’appel d’une fonction que l’on détermine un environnement. La nuance est importante car une même fonction appelée plusieurs fois définit plusieurs environnements différents.\n\n\n\n\n\nQuestion 2\n\nDans le code ci-dessous :\n\nx &lt;- 4\nfonction &lt;-\n  function(val) {\n    x &lt;- val\n    return(x)\n  }\nfonction(3)\n\nLe x dans l’environnement global est effacé de manière irrémédiable.\n\n\n\n\n ✗Vrai\n\n\n ✓Faux\n\n\nEffacer la réponse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRéponse\n\n\n\n\n\nNon, l’assignation simple affecte des valeurs dans l’environnement créé lors de l’appel d’une fonction et il n’y a strictement aucun danger de conflit.\n\n\n\n\n\nQuestion 3\n\nDans le code ci-dessous :\n\nx &lt;- 4\nfonction &lt;-\n  function(val) {\n    x &lt;&lt;- val\n    return(x)\n  }\nfonction(3)\n\nLe x dans l’environnement global est effacé de manière irrémédiable.\n\n\n\n\n ✓Vrai\n\n\n ✗Faux\n\n\nEffacer la réponse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRéponse\n\n\n\n\n\nVrai, l’assignation remontante &lt;&lt;- remonte les environnements parents jusqu’à retrouver un objet de même nom. Ici, elle va donc modifier le x de l’environnement global.\n\n\n\n\n\nQuestion 4\n\nDans le code ci-dessous :\n\nx &lt;- 4\nfonction &lt;-\n  function(val) {\n    x &lt;- 0\n    x &lt;&lt;- val\n    return(x)\n  }\nfonction(3)\n\nLe x dans l’environnement global est effacé de manière irrémédiable.\n\n\n\n\n ✓Vrai\n\n\n ✗Faux\n\n\nEffacer la réponse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRéponse\n\n\n\n\n\nVrai, l’assignation remontante &lt;&lt;- remonte les environnements parents jusqu’à retrouver un objet de même nom. Ici, elle va donc modifier le x de l’environnement global.\n\n\n\n\n\nQuestion 5\n\nDans le code ci-dessous :\n\nx &lt;- 4\nfonction &lt;- function() {\n  x &lt;- 0\n  function(val) {\n    x &lt;&lt;- val\n    return(x)\n  }\n}\n\nfonction()(3)\n\nLe x dans l’environnement global est effacé de manière irrémédiable.\n\n\n\n\n ✗Vrai\n\n\n ✓Faux\n\n\nEffacer la réponse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRéponse\n\n\n\n\n\nFaux, l’assignation remontante &lt;&lt;- remonte les environnements parents jusqu’à retrouver un objet de même nom. Ici, le premier environnement parent est celui instancié par fonction. Et il s’avère qu’il contient un objet de nom x. Donc le x de l’environnement global n’est pas écrasé.\n\n\n\n\n\nQuestion 6\n\nDans le code ci-dessous :\n\nx &lt;- 4\nfonction &lt;- function() {\n  function(val) {\n    x &lt;&lt;- val\n    return(x)\n  }\n}\n\nfonction()(3)\n\nLe x dans l’environnement global est effacé de manière irrémédiable.\n\n\n\n\n ✓Vrai\n\n\n ✗Faux\n\n\nEffacer la réponse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRéponse\n\n\n\n\n\nVrai, l’assignation remontante &lt;&lt;- remonte les environnements parents jusqu’à retrouver un objet de même nom. Ici, le premier environnement parent est celui instancié par fonction. Mais il ne contient aucun objet de nom x. On remonte donc encore les environnements jusqu’à l’environnement global, et donc le x global est modifié.",
    "crumbs": [
      "Fonctions d'ordre supérieur 2 (retours)"
    ]
  },
  {
    "objectID": "fonctions_ordre_superieur_2.html#exercice",
    "href": "fonctions_ordre_superieur_2.html#exercice",
    "title": "Fonctions d’ordre supérieur (retours)",
    "section": "Exercice",
    "text": "Exercice\nSupposons que l’on ait une fonction qui mette longtemps à répondre, par exemple :\n\ncalcul_de_dingue &lt;- function(arg) {\n  Sys.sleep(3L) # Une attente de 3 secondes pour simuler un long calcul.\n  return(2 * arg)\n}\n\nOù arg est un vecteur numérique.\nComment utiliser une closure pour définir une fonction calcul_moins_dingue qui renvoie les mêmes valeurs que calcul_de_dingue pour les mêmes entrées mais stocke les résultats pour éviter de relancer les calculs plus d’une fois ?\nL’idée est que calcul_moins_dingue appelle calcul_de_dingue si elle n’a pas été déjà appelée, et stocke le résultat dans une liste. Tout appel subséquent de calcul_moins_dingue doit alors restituer le résultat stocké plutôt que de réappeler calcul_de_dingue. On appelle ce principe un cache ; l’axiome sous-jacent est que calcul_de_dingue est une fonction pure (on peut complètement prévoir son résultat à partir de ses arguments).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nAide (à consulter après s’être un peu creusé la tête)\n\n\n\n\n\n\ncalcul_de_dingue &lt;- function(arg) {\n  Sys.sleep(3L) # Une attente de 3 secondes pour simuler un long calcul.\n  return(2 * arg)\n}\n\ncalcul_de_dingue_cache &lt;- function(taille_cache = 10L) {\n  cache &lt;- vector(\"list\",taille_cache)\n  cache_suivant &lt;- 1L\n  function(arg) {\n    index_en_cache &lt;- which(vapply(cache, \\(x) identical(x$arg,arg), TRUE))[1L]\n    # Cette ligne précédente peut être remplacée par\n    # index_en_cache &lt;- Position(\\(x) identical(x$arg,arg), cache)\n    # Qui fait la même chose (mais on n'a pas vu Position)\n    if (is.na(index_en_cache)) {\n      # Remplir ici\n      # C'est le cas où l'on ne retrouve pas la bonne entrée dans la cache.\n    }\n    else {\n      # Remplir ici \n      # C'est le cas où index_en_cache contient le numéro de cache et donc on\n      # n'a pas à refaire le calcul.\n    }\n  }\n}\n\ncalcul_moins_dingue &lt;- calcul_de_dingue_cache()\ncalcul_moins_dingue(c(1, 3))\ncalcul_moins_dingue(c(1, 3)) # Pas besoin de calcul, déjà en cache\ncalcul_moins_dingue(c(4, 7))\ncalcul_moins_dingue(c(4, 7)) # Pas besoin de calcul, déjà en cache\ncalcul_moins_dingue(c(1, 3)) # Pas besoin de calcul, déjà en cache\ncalcul_moins_dingue(c(4, 7)) # Pas besoin de calcul, déjà en cache\n\n\n\n\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\ncalcul_de_dingue &lt;- function(arg) {\n  Sys.sleep(3L) # Une attente de 3 secondes pour simuler un long calcul.\n  return(2 * arg)\n}\n\ncalcul_de_dingue_cache &lt;- function(taille_cache = 10L) {\n  cache &lt;- vector(\"list\",taille_cache)\n  cache_suivant &lt;- 1L\n  function(arg) {\n    index_en_cache &lt;- which(vapply(cache, \\(x) identical(x$arg,arg), TRUE))[1L]\n    # Cette ligne précédente peut être remplacée par\n    # index_en_cache &lt;- Position(\\(x) identical(x$arg,arg), cache)\n    # Qui fait la même chose (mais on n'a pas vu Position)\n    if (is.na(index_en_cache)) {\n      valeur &lt;- calcul_de_dingue(arg)\n      cache[[cache_suivant]] &lt;&lt;- list(arg = arg,\n                                      valeur = valeur)\n      cache_suivant &lt;&lt;- cache_suivant %% taille_cache + 1L\n      valeur\n    }\n    else cache[[index_en_cache]]$valeur\n  }\n}\n\ncalcul_moins_dingue &lt;- calcul_de_dingue_cache()\ncalcul_moins_dingue(c(1, 3))\n\n[1] 2 6\n\ncalcul_moins_dingue(c(1, 3)) # Pas besoin de calcul, déjà en cache\n\n[1] 2 6\n\ncalcul_moins_dingue(c(4, 7))\n\n[1]  8 14\n\ncalcul_moins_dingue(c(4, 7)) # Pas besoin de calcul, déjà en cache\n\n[1]  8 14\n\ncalcul_moins_dingue(c(1, 3)) # Pas besoin de calcul, déjà en cache\n\n[1] 2 6\n\ncalcul_moins_dingue(c(4, 7)) # Pas besoin de calcul, déjà en cache\n\n[1]  8 14",
    "crumbs": [
      "Fonctions d'ordre supérieur 2 (retours)"
    ]
  },
  {
    "objectID": "fonctions.html",
    "href": "fonctions.html",
    "title": "Rappel sur les fonctions en R",
    "section": "",
    "text": "En R, on définit une fonction de cette manière :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLa fonction super_calcul a plusieurs paramètres : a, b et multiplication. On donne à ces paramètres des valeurs qu’on appelle arguments. Toutefois, dans le langage courant, et peut-être dans cette formation si je ne fais pas trop attention, on utilise parfois indistinctement les deux mots.\nOn remarque que le paramètre multiplication a un argument par défaut. Si on omet de lui donner une valeur, sa valeur par défaut sera TRUE.\nOn remarque aussi que, lorsque l’on fait des appels de fonctions, l’on peut choisir d’utiliser explicitement les noms des différents paramètres. Si on utilise les noms explicites, il est possible de les renseigner dans le désordre.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLe code ci-dessus renvoie une erreur. En effet, si un paramètre n’a pas de valeur par défaut, une valeur doit obligatoirement être assignée lors de l’appel de fonction.\n\n\n\n\n\n\nNote\n\n\n\nLa dernière remarque n’est pas complètement vraie. Du vieux code persiste dans R, renseignant des arguments par défaut dans le code même de la fonction, à l’aide de if (missing(argument)) {}. Ceci est toutefois, en général, considéré comme une mauvaise pratique.\n\n\nOn vient de constater de manière implicite un aspect de R : par défaut, la valeur retournée par une fonction est la dernière valeur évaluée lors de son exécution (qui dépend éventuellement de structures telles que if () else {}). Une manière explicite de renvoyer une valeur de retour est d’invoquer return(). Appeler return() met fin à l’exécution de la fonction. Tout ce qui vient après n’est jamais rappelé.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\ncalcula() renvoie 2L, tandis que calculb() renvoie 3L. On aurait pu également constater que, dans calcula, si on remplace 3L par stop(), le stop n’empêche pas la fonction de retourner convenablement. En effet, il arrive après le return.",
    "crumbs": [
      "Rappel sur les fonctions en R"
    ]
  },
  {
    "objectID": "fonctions.html#définition-de-fonction",
    "href": "fonctions.html#définition-de-fonction",
    "title": "Rappel sur les fonctions en R",
    "section": "",
    "text": "En R, on définit une fonction de cette manière :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLa fonction super_calcul a plusieurs paramètres : a, b et multiplication. On donne à ces paramètres des valeurs qu’on appelle arguments. Toutefois, dans le langage courant, et peut-être dans cette formation si je ne fais pas trop attention, on utilise parfois indistinctement les deux mots.\nOn remarque que le paramètre multiplication a un argument par défaut. Si on omet de lui donner une valeur, sa valeur par défaut sera TRUE.\nOn remarque aussi que, lorsque l’on fait des appels de fonctions, l’on peut choisir d’utiliser explicitement les noms des différents paramètres. Si on utilise les noms explicites, il est possible de les renseigner dans le désordre.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLe code ci-dessus renvoie une erreur. En effet, si un paramètre n’a pas de valeur par défaut, une valeur doit obligatoirement être assignée lors de l’appel de fonction.\n\n\n\n\n\n\nNote\n\n\n\nLa dernière remarque n’est pas complètement vraie. Du vieux code persiste dans R, renseignant des arguments par défaut dans le code même de la fonction, à l’aide de if (missing(argument)) {}. Ceci est toutefois, en général, considéré comme une mauvaise pratique.\n\n\nOn vient de constater de manière implicite un aspect de R : par défaut, la valeur retournée par une fonction est la dernière valeur évaluée lors de son exécution (qui dépend éventuellement de structures telles que if () else {}). Une manière explicite de renvoyer une valeur de retour est d’invoquer return(). Appeler return() met fin à l’exécution de la fonction. Tout ce qui vient après n’est jamais rappelé.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\ncalcula() renvoie 2L, tandis que calculb() renvoie 3L. On aurait pu également constater que, dans calcula, si on remplace 3L par stop(), le stop n’empêche pas la fonction de retourner convenablement. En effet, il arrive après le return.",
    "crumbs": [
      "Rappel sur les fonctions en R"
    ]
  },
  {
    "objectID": "fonctions.html#dots",
    "href": "fonctions.html#dots",
    "title": "Rappel sur les fonctions en R",
    "section": "Dots",
    "text": "Dots\nLorsque le nombre de paramètres d’une fonction peut être variable, on peut utiliser les ... qu’on appelle “dots”. list(...) permet de retrouver ces arguments sous forme de liste dans le corps de la fonction.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDans le code précédent, on a pu faire une fonction de somme sans figer à l’avance le nombre de termes de la somme.\n\n\n\n\n\n\nNote\n\n\n\nOn a utilisé dans super_somme une fonction particulière, Reduce, qui est typique des langages fonctionnels. L’idée est ici que l’on calcule 2 + 3 + 7 + 1. On verra plus en détail ce type d’opérations dans la partie dédiée au paradigme fonctionnel.\nDans le cas présent, sum existe déjà et peut déjà s’appliquer à un vecteur. On n’a écrit super_somme qu’à fin d’illustration.",
    "crumbs": [
      "Rappel sur les fonctions en R"
    ]
  },
  {
    "objectID": "fonctions.html#appeler-une-fonction-dots-sur-une-liste",
    "href": "fonctions.html#appeler-une-fonction-dots-sur-une-liste",
    "title": "Rappel sur les fonctions en R",
    "section": "Appeler une fonction dots sur une liste",
    "text": "Appeler une fonction dots sur une liste\nImaginons que l’on veuille appeler une fonction ... sur une liste. On souhaite que chaque élément de la liste devienne un argument. On peut par exemple faire, sur notre fonction super_somme.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nNote\n\n\n\nLa fonction do.call est en réalité plus générale que cela. Elle permet également d’utiliser des arguments nommés, comme on peut le voir dans l’exemple suivant :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Rappel sur les fonctions en R"
    ]
  },
  {
    "objectID": "fonctions.html#fonction-récursives",
    "href": "fonctions.html#fonction-récursives",
    "title": "Rappel sur les fonctions en R",
    "section": "Fonction récursives",
    "text": "Fonction récursives\nLes fonctions en R peuvent tout-à-fait être récursives. Par exemple, même si factorial() existe déjà dans R, on pourrait très bien la redéfinir via :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nR permet également une petite astuce pour éviter d’avoir à utiliser le nom d’une fonction dans son propre corps (cela permet de pouvoir renommer la fonction à un seul endroit). Le code précédent est équivalent à :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nRemarque optionnelle\n\n\n\nDepuis la dernière version de R (pas avant !), on peut utiliser la fonction Tailcall pour faire des récursivités terminales ; qui sont moins pratiques à lire mais plus efficaces. L’interface n’est pas encore figée mais cela ressemble aujourd’hui à cela.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Rappel sur les fonctions en R"
    ]
  },
  {
    "objectID": "fonctions.html#exercices",
    "href": "fonctions.html#exercices",
    "title": "Rappel sur les fonctions en R",
    "section": "Exercices",
    "text": "Exercices\nQuestion 1\nRéécrire la fonction super_somme en utilisant une syntaxe récursive. On pourra, par exemple, s’aider de la fonction head, qui permet de retourner une sous-liste contenant les n premiers éléments d’une liste.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\nsuper_somme &lt;- function(...) {\n  dots &lt;- list(...)\n  longueur &lt;- length(dots)\n  if (longueur == 0L) 0\n  else dots[[longueur]] + do.call(super_somme, head(dots, longueur - 1L))\n}\nprint(super_somme(2, 3, 7, 1))\n\n[1] 13\n\n\n\n\n\n\n\n\nRemarque\n\n\n\n\nLa récursivité est ici très bourrine ! On le fait juste pour l’exercice.\nQuelques petites astuces permettent, si besoin, d’éviter de convertir tous les arguments d’une fonction dots en liste. On dispose par exemple de ...length() en tant que substitut pour length(list(...)).\n\n\n\n\n\n\nQuestion 2\nEcrire une fonction ... super_produit qui calcule le produit de tous les arguments, et l’utiliser pour écrire une nouvelle version de la fonction fact.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\nsuper_produit &lt;- function(...) {\n  dots &lt;- list(...)\n  Reduce(`*`, dots)\n}\nfact &lt;- function(n) {\n  do.call(super_produit, as.list(1L:n))\n}\nfact(10)\n\n[1] 3628800\n\n\n\n\n\nQuestion 3\nEcrire une fonction dots usine_a_gaz qui renvoie :\n\nNULL s’il n’y a aucun argument.\nLe nombre d’arguments s’il y en a deux ou plus.\n\"bonjour\" si on lui soumet en unique argument un vecteur de type character.\nLa somme du vecteur si on lui soumet en unique argument un vecteur numérique au sens de is.numeric.\n\"échec\" dans tous les autres cas.\n\nOn pourra éventuellement s’aider des petites astuces, dont ...length(), lisibles dans la page d’aide des .... Celle-ci est accessible en tapant ?dots.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nProposition de solution\n\n\n\n\n\n\nusine_a_gaz &lt;- function(...) {\n  longueur &lt;- ...length()\n  if (longueur == 0) NULL\n  else if (longueur &gt;= 2L) longueur\n  else if (is.character(..1)) \"bonjour\"\n  else if (is.numeric(..1)) sum(..1)\n  else \"échec\"\n}\nprint(usine_a_gaz())\n\nNULL\n\nprint(usine_a_gaz(1,3))\n\n[1] 2\n\nprint(usine_a_gaz(c(\"a\",\"b\")))\n\n[1] \"bonjour\"\n\nprint(usine_a_gaz(c(1, 2)))\n\n[1] 3\n\nprint(usine_a_gaz(c(1L, 2L)))\n\n[1] 3\n\nprint(usine_a_gaz(list()))\n\n[1] \"échec\"\n\n\nOn peut également utiliser des return(), auquel cas les else deviennent inutiles puisque return fait directement retourner la fonction.\n\nusine_a_gaz &lt;- function(...) {\n  longueur &lt;- ...length()\n  if (longueur == 0) return(NULL)\n  if (longueur &gt;= 2L) return(longueur)\n  if (is.character(..1)) return(\"bonjour\")\n  if (is.numeric(..1)) return(sum(..1))\n  \"échec\"\n}\nprint(usine_a_gaz())\n\nNULL\n\nprint(usine_a_gaz(1,3))\n\n[1] 2\n\nprint(usine_a_gaz(c(\"a\",\"b\")))\n\n[1] \"bonjour\"\n\nprint(usine_a_gaz(c(1, 2)))\n\n[1] 3\n\nprint(usine_a_gaz(c(1L, 2L)))\n\n[1] 3\n\nprint(usine_a_gaz(list()))\n\n[1] \"échec\"",
    "crumbs": [
      "Rappel sur les fonctions en R"
    ]
  }
]